PROGRAM _CYCLIC
<?AutomationStudio FileVersion="4.9"?>
INITIAL_STEP Stp_Init:
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_INIT;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Stp_Init TO Stp_ModeCheck:=
TRUE
END_TRANSITION
(* @SFCNOJUMP := 'Stp_ModeCheck' *)
STEP Stp_ModeCheck:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_MODE_CHECK;
END_ACTION
TRANSITION Not in prod mode FROM Stp_ModeCheck TO Stp_WaitForProd:=
(* @LANGUAGE := 'st' *)
// Not in production mode
operatingMode.OperatingMode <> OM_PRODUCTION_MODE
END_TRANSITION
(* @SFCNOJUMP := 'Stp_WaitForProd' *)
TRANSITION In prod mode FROM Stp_ModeCheck TO Stp_ProdWaitForStart:=
(* @LANGUAGE := 'st' *)
// In production mode
operatingMode.OperatingMode = OM_PRODUCTION_MODE
END_TRANSITION
(* @SFCNOJUMP := 'Stp_ProdWaitForStart' *)
STEP Stp_ProdWaitForStart:
(* @LANGUAGE := 'st' *)
// These calcs will put results in the local partMotion structure.
// Do these calcs now so they are known before hand, and can be displayed now
// and used later.
CalcPartMotion;


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_WAIT_FOR_START;

// Disable axes while waiting to start
(*
axes[AD_SPINDLE].Commands.DisableReq := TRUE;
axes[AD_OUTER_ECCENTRIC].Commands.DisableReq := TRUE;
axes[AD_INNER_ECCENTRIC].Commands.DisableReq := TRUE;
axes[AD_Z].Commands.DisableReq := TRUE;
*)
// Clear in cycle bit to safety PLC
ts_InCycle := FALSE;

// Unlock the cutting fluid gate when not in cycle
ts_cfLockGate := FALSE;
END_ACTION
TRANSITION Not in prod mode FROM Stp_ProdWaitForStart TO Stp_ModeCheck:=
(* @LANGUAGE := 'st' *)
// Not in production mode
operatingMode.OperatingMode <> OM_PRODUCTION_MODE
END_TRANSITION
(* @SFCISJUMP := 'Stp_ModeCheck' *)
TRANSITION Req cycle start FROM Stp_ProdWaitForStart TO Stp_EnableAxes:=
(* @LANGUAGE := 'st' *)
// In production mode and a cycle start is made
operatingMode.OperatingMode = OM_PRODUCTION_MODE AND
cyclePermissives.allowCycleStart AND
operatingMode.ReqCycleStart
END_TRANSITION
(* @SFCNOJUMP := 'Stp_EnableAxes' *)
STEP Stp_EnableAxes:
(* @LANGUAGE := 'st' *)
// Run step hold and timeout timers (PT set in step entry)
tmrStepMin(IN:= TRUE);
tmrStepTO(IN:= TRUE);

// Set in cycle signal to safe PLC
ts_InCycle := TRUE;

// Lock the cutting fluid gate in cycle
ts_cfLockGate := TRUE;



END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_ENABLE_AXES;

// machine is in cycle
operatingMode.isInCycle := TRUE;
operatingMode.isStopping := FALSE;

// Init pass count to the first pass
gr_PartCurrent.cutPassCount := 1;

// Reset step hold and timeout timers
tmrStepMin(IN:= FALSE, PT:= T#100ms);
tmrStepTO(IN:= FALSE, PT:= T#2s);


// Set the vfd speed, and request start if not already running
// Request to start now, check for flow in a little bit.
// TODO:
// cfVfd.ReqAutoSpeedEU := gr_CfgCurrent.cfVfd.speedPct;
// cfVfd.ReqAutoStart := cfVfd.State = MTRVFD_REM_AUTO_STOP;

// Enable the axes if they are not already
axes[AD_SPINDLE].Commands.EnableReq := (axes[AD_SPINDLE].Status.PlcOpenState = mcAXIS_DISABLED);
axes[AD_OUTER_ECCENTRIC].Commands.EnableReq := (axes[AD_OUTER_ECCENTRIC].Status.PlcOpenState = mcAXIS_DISABLED);
axes[AD_INNER_ECCENTRIC].Commands.EnableReq := (axes[AD_INNER_ECCENTRIC].Status.PlcOpenState = mcAXIS_DISABLED);
axes[AD_Z].Commands.EnableReq := (axes[AD_Z].Status.PlcOpenState = mcAXIS_DISABLED);

// Decouple the inner eccentric from the outer eccentric to start with. This is so
// the inner eccentric can be easily moved back to zero depth position if this is needed.
// It will already be decoupled if the axis was disabled. It could have been
// enabled and coupled while waiting for a cycle start -- in which case it could still be 
// coupled.
axes[AD_OUTER_ECCENTRIC].CouplingParameters.GearInCmd:= FALSE;
axes[AD_OUTER_ECCENTRIC].CouplingParameters.GearInPosCmd:= FALSE;
axes[AD_OUTER_ECCENTRIC].CouplingParameters.OffsetShiftCmd:= FALSE;
axes[AD_OUTER_ECCENTRIC].CouplingParameters.PhaseShiftCmd:= FALSE;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_EnableAxes TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CycleStop' *)
TRANSITION min time and axes enabled FROM Stp_EnableAxes TO Stp_ZeroDepth:=
(* @LANGUAGE := 'st' *)
// minimum time, axes are enabled, and inner eccentric is not coupled
tmrStepMin.Q AND
axes[AD_SPINDLE].Status.PlcOpenState = mcAXIS_STANDSTILL AND
axes[AD_OUTER_ECCENTRIC].Status.PlcOpenState = mcAXIS_STANDSTILL AND
axes[AD_INNER_ECCENTRIC].Status.PlcOpenState = mcAXIS_STANDSTILL AND
axes[AD_Z].Status.PlcOpenState = mcAXIS_STANDSTILL
END_TRANSITION
(* @SFCNOJUMP := 'Stp_ZeroDepth' *)
STEP Stp_ZeroDepth:
(* @LANGUAGE := 'st' *)
// Run step hold and timeout timers (PT set in step entry)
tmrStepMin(IN:= TRUE);
tmrStepTO(IN:= TRUE);

// Make sure the Z Index info is up to date
CalcZIndex;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_ZERO_DEPTH;

// Reset TO tmr
// Set TO time to longer than is necessary for the move
// Calc PT time based on distance and velocity, which will be a bit low since it does not take into account accel and decel.
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, (ABS(axes[AD_INNER_ECCENTRIC].Status.CalculatedPosition1) / gr_CfgCurrent.cuttingHead.retractRate)); // deg / deg/sec = sec 
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// Run inner eccentric back to zero depth. The "zero" depth spot moves with the outer eccentric,
// so do a relative move back by the angular difference to the outer eccentric axis.
// This assumes the zero/home position of both the Outer and Inner axes was set to zero when
// the index lines are lined up with each other.
// For the inner axis, the angular difference to the outer eccentric is stored in CalculatedPosition1
axes[AD_INNER_ECCENTRIC].MoveParameters.Distance := (-1.0 * axes[AD_INNER_ECCENTRIC].Status.CalculatedPosition1);
// Use the retract velocity
axes[AD_INNER_ECCENTRIC].MoveParameters.Velocity := gr_CfgCurrent.cuttingHead.retractRate; // deg/sec
axes[AD_INNER_ECCENTRIC].MoveParameters.Acceleration := gr_CfgCurrent.cuttingHead.accel;
axes[AD_INNER_ECCENTRIC].MoveParameters.Deceleration := gr_CfgCurrent.cuttingHead.decel;
axes[AD_INNER_ECCENTRIC].Commands.MoveRelativeReq := TRUE;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_ZeroDepth TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION min time zero depth and indexed FROM Stp_ZeroDepth TO Stp_CycleHold1:=
(* @LANGUAGE := 'st' *)
// Minimum time expired and inner axis is done moving and depth tolerance is good (depth ~0)
tmrStepMin.Q AND
axes[AD_INNER_ECCENTRIC].Status.IsInPosition AND axes[AD_INNER_ECCENTRIC].Status.PlcOpenState = mcAXIS_STANDSTILL AND // isMoveDone will get cleared when SM removes cmd
ABS(axes[AD_INNER_ECCENTRIC].Status.CalculatedPosition1) < TOL_DEPTH_ZERO_DEG AND
// Z-Axis is indexed and index is >= 1, meaning it is at least at the start position
gr_PartCurrent.isZIndexed AND gr_PartCurrent.zIndexCount >= 1
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CycleHold1' *)
STEP Stp_CycleHold1:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION Stop Req FROM Stp_CycleHold1 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Stop Req
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION continue FROM Stp_CycleHold1 TO Stp_NextCycle:=
(* @LANGUAGE := 'st' *)
// Operating mode is continuous OR
// single cycle OR
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
operatingMode.SubMode = OM_PROD_SM_SINGLE OR // one cycle at a time
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // One step at a time
END_TRANSITION
(* @SFCNOJUMP := 'Stp_NextCycle' *)
STEP Stp_NextCycle:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_NEXT_CYCLE;
END_ACTION
TRANSITION cf good FROM Stp_NextCycle TO Stp_StartSpindle:=
(* @LANGUAGE := 'st' *)
// Cutting fluid pump is running and flow is good
cfVfd.isRunning AND
cfVfd.isFlowEstablished
END_TRANSITION
(* @SFCNOJUMP := 'Stp_StartSpindle' *)
STEP Stp_StartSpindle:
(* @LANGUAGE := 'st' *)
// Run step hold and timeout timers (PT set in step entry)
tmrStepMin(IN:= TRUE);
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_START_SPINDLE;

// Reset step minimum timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);
// Reset TO tmr
// Set TO time to longer than is necessary to accel from to
// Calc PT time based on velocity and acceleration
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, ((gr_CfgCurrent.spindle.nomRpm / 60.0) / gr_CfgCurrent.spindle.accel)); // rev/sec / rev/sec^2 = sec
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// Start spindle at the configured speed.
// Spindle will continue until error, or another req is made, or the vel req is removed.
axes[AD_SPINDLE].MoveParameters.Velocity := (gr_CfgCurrent.spindle.nomRpm / 60.0); // drive is in rps
axes[AD_SPINDLE].MoveParameters.Acceleration := gr_CfgCurrent.spindle.accel;
axes[AD_SPINDLE].MoveParameters.Deceleration := gr_CfgCurrent.spindle.decel;
axes[AD_SPINDLE].MoveParameters.Direction := mcDIR_POSITIVE ;
axes[AD_SPINDLE].Commands.MoveVelocityReq := TRUE;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_StartSpindle TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION min time spindle at speed and coupling rdy FROM Stp_StartSpindle TO Stp_CycleHold4:=
(* @LANGUAGE := 'st' *)
// Minimum time expired, and spindle velocity is reached, and master and slave are ready for coordination
tmrStepMin.Q AND
axes[AD_SPINDLE].Status.IsInVelocity AND
axes[AD_OUTER_ECCENTRIC].Status.IsCoordSlaveReady AND 
axes[AD_OUTER_ECCENTRIC].Status.IsCoordMasterReady
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CycleHold4' *)
STEP Stp_CycleHold4:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION Stop Req FROM Stp_CycleHold4 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Stop Req
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION continue FROM Stp_CycleHold4 TO Stp_GearInEcc:=
(* @LANGUAGE := 'st' *)
// Operating mode is continuous OR
// single cycle OR
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
operatingMode.SubMode = OM_PROD_SM_SINGLE OR // one cycle at a time
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // One step at a time
END_TRANSITION
(* @SFCNOJUMP := 'Stp_GearInEcc' *)
STEP Stp_GearInEcc:
(* @LANGUAGE := 'st' *)
// Run step TO timer (PT set in step entry)
tmrStepTO(IN:= TRUE);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_GEAR_IN_ECC;

// Reset step minimum timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);
// Reset TO tmr
// No move, so just use a value so we don't get hung up here
tmrStepTO(IN:= FALSE, PT:= T#1s);

// Set the gear in of the inner eccentric to the outer eccentric.
// Use Gear In Position to create the initial offset.

// Ratio Reference
// RatioNumerator = Gear factor of the slave / Measurement resolution of the slave
// RatioDenominator = Gear factor of the master / Measurement resolution of the master
// We generally want 1:1, and both axes have a resolution of .001 => 1 / .001 = 1000
axes[AD_OUTER_ECCENTRIC].CouplingParameters.RatioNumerator := 1000;
axes[AD_OUTER_ECCENTRIC].CouplingParameters.RatioDenominator := 1000;

// Use pos. sp for master pos source. Good when master has closed loop pos ctrl.
axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterPositionSource := mcVALUE_SET; 

// Sync mode, go fwd
axes[AD_OUTER_ECCENTRIC].CouplingParameters.SyncMode := mcSYNC_MODE_POSITIVE;

// Master position from which the slave moves synchronously is the current master position
// plus the depth adj angle
axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterSyncPosition := fctLRMod(axes[AD_OUTER_ECCENTRIC].Status.Position + partMotion.depthAdjAngle, 360.0);

// Slave position from which the slave moves synchronously is the master sync position, plus the pass offset angle
axes[AD_OUTER_ECCENTRIC].CouplingParameters.SlaveSyncPosition := fctLRMod(axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterSyncPosition + partMotion.passOffsetAngle, 360.0);

// Master start distance during which the slave synchronizes. Use the depth adj dist.
axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterStartDistance := partMotion.depthAdjAngle;

// For velocity, allow the configured maximum
axes[AD_OUTER_ECCENTRIC].CouplingParameters.ShiftVelocityMax := axes[AD_INNER_ECCENTRIC].MoveParameters.VelocityMax; 
axes[AD_OUTER_ECCENTRIC].CouplingParameters.ShiftAccelerationMax := 0.0; // use slave axis limit
axes[AD_OUTER_ECCENTRIC].CouplingParameters.ShiftDecelerationMax := 0.0; // use slave axis limit
axes[AD_OUTER_ECCENTRIC].CouplingParameters.ShiftJerk := 0.0; // Jerk not supported

// Execute the gear in position command once the update parmeters req has at least been seen.
// Update should not be needed since the axes are not geared yet.
axes[AD_OUTER_ECCENTRIC].CouplingParameters.GearInPosCmd := TRUE;



END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_GearInEcc TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION Inner Ecc Coupled FROM Stp_GearInEcc TO Stp_StartPass:=
(* @LANGUAGE := 'st' *)
axes[AD_INNER_ECCENTRIC].Status.PlcOpenState = mcAXIS_SYNCHRONIZED_MOTION
END_TRANSITION
(* @SFCNOJUMP := 'Stp_StartPass' *)
STEP Stp_StartPass:
(* @LANGUAGE := 'st' *)
// Run step hold and timeout timers (PT set in step entry)
tmrStepMin(IN:= TRUE);
tmrStepTO(IN:= TRUE);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_START_PASS;

// Reset step minimum timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);
// Reset TO tmr.
// The move is started here, and will traverse thru the adj angle in this step.
// Set TO time to longer than is necessary to travel the adj angle.
// Calc PT time based on velocity and travel distance -- which will be a bit low since it doesn't take accel into account
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, (partMotion.depthAdjAngle / partMotion.cutVelocity)); // deg / deg/sec = sec
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// The pass or cut distance is a full revolution, plus the depth adj angle, plus the cut overrun angle.
// The adjustment zone to either retract the cutters or go to a new depth for an additional pass is part of the next path. 
// Note this distance does not change unless the part cfg changes, so it is only calculated here, at the start of a cycle.
partMotion.passDistance := 360.0 + partMotion.depthAdjAngle + gr_CfgCurrent.cuttingHead.cutOverrunAngle; // total number of degrees. 

// Point where 1st pass has been made, including overcut. Ready for the next depth/retract starting at this point.
partMotion.endOfPassPosition := fctLRMod(axes[AD_OUTER_ECCENTRIC].Status.Position + partMotion.passDistance, 360.0);

// Calculate the azimuth when the next adjustment finishes.
// The next time around, the depth will be at the new depth or retracted when the outer eccentric gets to this point.
// The outer eccentric has to get past this point before a new adjustment is set up, so the heads are forced to go all
// the way around before reaching this point again.
// Instead of calculating a position, calculate the distance that needs to be traveled to get the 
// outer eccentric past this azimuth -- this way this value is comparable to distance traveled.
// The distance is the depth adj angle for this cut, and the next pass, plus the overcut angle.
partMotion.calcNextAdjDistance :=  (2 * partMotion.depthAdjAngle) + gr_CfgCurrent.cuttingHead.cutOverrunAngle;  
// Keep the position for informational and troubleshooting purposes.
partMotion.calcNextAdjPosition :=  fctLRMod(partMotion.endOfPassPosition + partMotion.depthAdjAngle, 360.0);

// Record the start of pass position -- used later to see when we have passed the next adj position.
// This has to handle the case where the start was just before 360, and the move rolls past 0 just
// after starting.
partMotion.startOfPassPosition := axes[AD_OUTER_ECCENTRIC].Status.Position;
partMotion.passDistanceTraveled := 0.0;

// Set the move parameters.
axes[AD_OUTER_ECCENTRIC].MoveParameters.Velocity := partMotion.cutVelocity;
axes[AD_OUTER_ECCENTRIC].MoveParameters.Acceleration := gr_CfgCurrent.cuttingHead.accel;
axes[AD_OUTER_ECCENTRIC].MoveParameters.Deceleration := gr_CfgCurrent.cuttingHead.decel;
axes[AD_OUTER_ECCENTRIC].MoveParameters.Direction := mcDIR_POSITIVE;

// Start a velocity move of the outer eccentric. The inner should follow after establishing an offset due to GearInPos.
// A velocity move is used so the heads will keep moving while depth is adjusted for the different passes. On the last
// pass, the move will be changed to an absolute move to the final position.
axes[AD_OUTER_ECCENTRIC].Commands.MoveVelocityReq := TRUE;

END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_StartPass TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION synching FROM Stp_StartPass TO Stp_Synching1:=
(* @LANGUAGE := 'st' *)
// Minimum time elapsed -- allow time for move to start and make sure status is accurate
tmrStepMin.Q AND
// outer eccentric master is moving and inner eccentric slave is synching up to the cut depth
axes[AD_OUTER_ECCENTRIC].Status.IsMoveActive AND
axes[AD_OUTER_ECCENTRIC].Status.IsCoordInCompensation

END_TRANSITION
(* @SFCNOJUMP := 'Stp_Synching1' *)
STEP Stp_Synching1:
(* @LANGUAGE := 'st' *)
// Run step TO timer (PT set in step entry)
tmrStepTO(IN:= TRUE);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_SYNCHING1;

// Reset step minimum timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);
// Reset TO tmr.
// The move was started in the previous step, but the bulk of the move will happen here.
// The transition getting us here should happen shortly after motion starts.
// In the first move case, velocity would be zero at the start of the move, 
// and the cut velocity at the end of the adjustment angle, so the average velocity
// is velocity/2, so the time would be arc / (vel/2)/ When arriving here from the
// next pass or finishing pass adj, the outer eccentric would already be at speed,
// so the time would be arc / vel, or a shorter time. To simplify the code,
// use the longer of the two: arc / (vel/2)
// Set TO time to longer than is necessary to reach velocity.
// Calc PT time based on velocity and acceleration.
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, (partMotion.depthAdjAngle / (partMotion.cutVelocity / 2.0))); // deg / deg/sec = sec
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_Synching1 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION moving and synched FROM Stp_Synching1 TO Stp_AxesSynched:=
(* @LANGUAGE := 'st' *)
// outer eccentric master is at speed and inner is synched
axes[AD_OUTER_ECCENTRIC].Status.IsMoveActive AND
axes[AD_OUTER_ECCENTRIC].Status.IsInVelocity AND
axes[AD_OUTER_ECCENTRIC].Status.IsCoordInSync
END_TRANSITION
(* @SFCNOJUMP := 'Stp_AxesSynched' *)
STEP Stp_AxesSynched:
(* @LANGUAGE := 'st' *)
// Run step TO timer (PT set in step entry)
tmrStepTO(IN:= TRUE);

// Calculate the pass distance traveled (position - starting point)
partMotion.passDistanceTraveled := fctAziDiff(axes[AD_OUTER_ECCENTRIC].Status.Position, partMotion.startOfPassPosition);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_AXES_SYNCHED;

// Reset step minimum timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);
// Reset TO tmr.
// This part of the move for the next adjustment distance, less an adjustment angle -- one adj angle was used up getting this pass synched.
// The move should already be at velocity.
// Set TO time to longer than is necessary to travel the adj angle.
// Calc PT time based on velocity and travel distance -- which will be a bit low since it doesn't take accel into account
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, ((partMotion.calcNextAdjDistance - partMotion.depthAdjAngle) / partMotion.cutVelocity)); // deg / deg/sec = sec
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_AxesSynched TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION last pass FROM Stp_AxesSynched TO Stp_SetRetract:=
(* @LANGUAGE := 'st' *)
// Cutting heads are synched and this is the last pass and there is no finising pass, or this is the finishing pass
// From the starting point, they will go a full revolution, plus an adjustment zone plus the cut overrun distance. Call this point T1.
// The next step is to calculate the next adjustment that will need to start at T1 and end after an adjustment angle.
// We will do this while running the cut, but we have to past the azimuth of the next adjustment point so the heads are
// forced to go all the way around before reaching this point again.
// The required distance was calculated earlier and stored in partMotion.calcNextAdjDistance
partMotion.passDistanceTraveled > partMotion.calcNextAdjDistance AND
// This is the last pass, and there is no finishig pass, or there is a finishing pass, and it is finishing up -- time to set the inner eccentric to the retracted position
(gr_PartCurrent.cutPassCount = gr_CfgCurrent.cuttingHead.passCount AND
NOT gr_CfgCurrent.cuttingHead.finishingPass) OR
gr_PartCurrent.cutPassCount > gr_CfgCurrent.cuttingHead.passCount
END_TRANSITION
(* @SFCNOJUMP := 'Stp_SetRetract' *)
STEP Stp_SetRetract:
(* @LANGUAGE := 'st' *)
// Run step TO timer (PT set in step entry)
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_SET_RETRACT;

// Reset TO tmr
// The majority of the cut happens here -- the outer eccentric goes from the next adjustment point to the end of the pass position, 
// where a new sync cycle starts. This which will normally be nearly a full rotation, depending on the adj angle and overcut distance.
// The move should already be at velocity.
// Set TO time to longer than is necessary to travel the adj angle.
// Calc PT time based on velocity and travel distance -- which will be a bit low since it doesn't take accel into account
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, ((partMotion.passDistance - partMotion.passDistanceTraveled) / partMotion.cutVelocity)); // deg / deg/sec = sec
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 


// Retract cutting head
// Set the gear in of the inner eccentric to the outer eccentric.
// Use Gear In Position to remove the offset, and retract the cutting heads -- the move should complete with the cutting heads retracted.
// Some of the parameters were already set when the offset was established.
// Only set the changes here.

// Master position from which the slave moves synchronously is the pass target position plus the adj angle
axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterSyncPosition := fctLRMod(partMotion.endOfPassPosition + partMotion.depthAdjAngle, 360.0);

// Slave position from which the slave moves synchronously is the master sync position -- inner and outer at the same position is retracted
axes[AD_OUTER_ECCENTRIC].CouplingParameters.SlaveSyncPosition := axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterSyncPosition;

// Master start distance during which the slave synchronizes. Use the depth adj dist.
axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterStartDistance := partMotion.depthAdjAngle;

// Update the endOfPassPosition
partMotion.endOfPassPosition := axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterSyncPosition;

// trigger a param update
axes[AD_OUTER_ECCENTRIC].Commands.UpdateCouplingParams := TRUE;

// Make the move a absolute move to the end of the pass, plus the adj angle to include the arc while the cutting head is being retracted.
// This is the updated end of pass position and the MasterSyncPosition
// TEST for bumpless transfer to new move. See if it makes any sense/difference if the initial move was a move absolute.
axes[AD_OUTER_ECCENTRIC].MoveParameters.Position := partMotion.endOfPassPosition;
axes[AD_OUTER_ECCENTRIC].Commands.MoveAbsoluteReq := TRUE;
axes[AD_OUTER_ECCENTRIC].Commands.MoveVelocityReq := FALSE; // Turn off the vel req

END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_SetRetract TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION synching FROM Stp_SetRetract TO Stp_Synching2:=
(* @LANGUAGE := 'st' *)
// Make sure the update has been processed, and the
// inner axis is compensating -- being brought into sync at the specified positions.
// This is the start of retracting the cutting heads.
NOT axes[AD_OUTER_ECCENTRIC].Commands.UpdateCouplingParams AND
axes[AD_OUTER_ECCENTRIC].Status.IsCoordInCompensation
END_TRANSITION
(* @SFCNOJUMP := 'Stp_Synching2' *)
STEP Stp_Synching2:
(* @LANGUAGE := 'st' *)
// Run step hold and timeout timers (PT set in step entry)
tmrStepMin(IN:= TRUE);
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_SYNCHING2;

// Reset step min hold tmr
tmrStepMin(IN:= FALSE);
// Reset TO tmr
// This portion of the move is over the last adjustment angle, where the heads are retracting.
// Approximate the time by assuming deceleration to zero starts at the beginning of the adjustment arc.
// In this case, the average velocity would be V/2.
// Set TO time to longer than is necessary to travel the adj angle.
// Calc PT time based on velocity and travel distance -- which will be a bit low since it doesn't take accel into account
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, (partMotion.depthAdjAngle / (partMotion.cutVelocity / 2.0))); // deg / deg/sec = sec
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_Synching2 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION cutting done depth wrong FROM Stp_Synching2 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Min step time done
tmrStepMin.Q AND
// Once the move completes, the cutting passes are done
axes[AD_OUTER_ECCENTRIC].Status.PlcOpenState = mcAXIS_STANDSTILL AND
// Make sure depth is zero
// Calculated pos 1 is the relative position of Inner and Outer Axes
ABS(axes[AD_INNER_ECCENTRIC].Status.CalculatedPosition1) > TOL_DEPTH_ZERO_DEG
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CycleStop' *)
TRANSITION min time and cutting done depth zero FROM Stp_Synching2 TO Stp_RecordIndex:=
(* @LANGUAGE := 'st' *)
// Min step time done
tmrStepMin.Q AND
// Once the move completes, the cutting passes are done
axes[AD_OUTER_ECCENTRIC].Status.PlcOpenState = mcAXIS_STANDSTILL AND
// Make sure depth is zero
// Calculated pos 1 is the relative position of Inner and Outer Axes
ABS(axes[AD_INNER_ECCENTRIC].Status.CalculatedPosition1) <= TOL_DEPTH_ZERO_DEG
 
END_TRANSITION
(* @SFCNOJUMP := 'Stp_RecordIndex' *)
STEP Stp_RecordIndex:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Record this index pos as successful
gr_PartCurrent.zIndexCountSuccess :=  gr_PartCurrent.zIndexCount;
END_ACTION
TRANSITION FROM Stp_RecordIndex TO Stp_CycleHold5:=
TRUE
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CycleHold5' *)
STEP Stp_CycleHold5:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION Stop Req FROM Stp_CycleHold5 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Stop Req
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION continue FROM Stp_CycleHold5 TO Stp_StopSpindle:=
(* @LANGUAGE := 'st' *)
// Operating mode is continuous OR
// single cycle OR
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
operatingMode.SubMode = OM_PROD_SM_SINGLE OR // one cycle at a time
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // One step at a time
END_TRANSITION
(* @SFCNOJUMP := 'Stp_StopSpindle' *)
STEP Stp_StopSpindle:
(* @LANGUAGE := 'st' *)
// Run step hold and timeout timers (PT set in step entry)
tmrStepMin(IN:= TRUE);
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_STOP_SPINDLE;

// Reset step hold timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);
// Reset TO tmr
// Set TO time to longer than is necessary to decel from velocity
// Calc PT time based on velocity and deceleration
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, ((gr_CfgCurrent.spindle.nomRpm / 60.0) / gr_CfgCurrent.spindle.decel)); // rev/sec / rev/sec^2 = sec
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 
tmrStepTO(IN:= FALSE, PT:= T#2s);

// Stop the spindle
axes[AD_SPINDLE].Commands.MoveVelocityReq := FALSE;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_StopSpindle TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION min time and spindle stopped FROM Stp_StopSpindle TO Stp_IndexZWait:=
(* @LANGUAGE := 'st' *)
// Min step time done
tmrStepMin.Q AND
// Spindle has stopped
axes[AD_SPINDLE].Status.PlcOpenState = mcAXIS_STANDSTILL
END_TRANSITION
(* @SFCNOJUMP := 'Stp_IndexZWait' *)
STEP Stp_IndexZWait:
(* @LANGUAGE := 'st' *)
// Calc Z index Info
CalcZIndex;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_INDEX_Z_WAIT;
END_ACTION
TRANSITION Stop Req FROM Stp_IndexZWait TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Stop Req
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION continue, idx dn, shutoff CF FROM Stp_IndexZWait TO Stp_CfOff1:=
(* @LANGUAGE := 'st' *)
// Normal indexing is done. Once continuing, shut off cutting fluid before indexing if configured to do so
gr_PartCurrent.zIndexCount >= partMotion.totalIndexes AND
operatingMode.ShutOffCfBeforeUnload AND
// Operating mode is continuous OR
// single cycle OR
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
operatingMode.SubMode = OM_PROD_SM_SINGLE OR // one cycle at a time
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // One step at a time

END_TRANSITION
(* @SFCNOJUMP := 'Stp_CfOff1' *)
STEP Stp_CfOff1:
(* @LANGUAGE := 'st' *)
// Run step hold and timer (PT set in step entry)
tmrStepMin(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_CF_OFF1;

// Reset step hold timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);

// Turn off CF pump -- won't work if pump is in manual mode
// TODO
// cfVfd.ReqAutoStop := TRUE;
END_ACTION
TRANSITION min time and cf stop req processed FROM Stp_CfOff1 TO Stp_CycleHold6:=
(* @LANGUAGE := 'st' *)
// Min time
tmrStepMin.Q //AND
// CF Auto stop request was processed 
// TODO
// NOT cfVfd.ReqAutoStop 
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CycleHold6' *)
STEP Stp_CycleHold6:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION Stop Req FROM Stp_CycleHold6 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Stop Req
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION continue FROM Stp_CycleHold6 TO Stp_ZToUnload:=
(* @LANGUAGE := 'st' *)
// Continue
// If in single cycle, continue if we want to include the index in the single cycle, 
// or if we don't but we get a start request. This allows the machine to stop before
// the index in single cycle, but then allows the operator to continue.

// Operating mode is continuous OR
// single cycle AND (incl index OR (dont' include index AND get a start press))
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
(operatingMode.SubMode = OM_PROD_SM_SINGLE AND // one cycle at a time
  (operatingMode.SingleCycleInclZIndex OR (NOT operatingMode.SingleCycleInclZIndex AND operatingMode.ReqCycleStart))) OR // incl Z index, or initially don't but then get start req
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // One step at a time
END_TRANSITION
(* @SFCNOJUMP := 'Stp_ZToUnload' *)
STEP Stp_ZToUnload:
(* @LANGUAGE := 'st' *)
// Calc Z Index info
CalcZIndex;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_Z_TO_UNLOAD;

// Reset step minimum timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);
// Reset step TO timer
// Set TO time to longer than is necessary for the move
// Use the trapazoidal move time fb to Calc PT time based on distance, velocity, accel, and decel.
// This should be a good approximate number, but not exact. It will be a bit low if jerk is used.
// Enforce a minimum time to rule out values <= 0
calcReal1 := 100.0; // in mSec when using the fb, 100 msec minimum
fbCalcMoveTimes(
  _I_Vel0 := 0.0,
_I_VelMove :=  gr_CfgCurrent.zAxis.indexSpeed,
_I_Accel := gr_CfgCurrent.zAxis.accel,
_I_Decel := gr_CfgCurrent.zAxis.decel,
_I_Dist := ABS(axes[AD_Z].Status.Position - gr_CfgCurrent.zAxis.loadUnloadPos)); // FB needs a distance

calcReal1 := MAX(calcReal1, DINT_TO_REAL(fbCalcMoveTimes._O_MoveTimeMsec)); // move time in msec
calcDint1 := REAL_TO_DINT(calcReal1 * 1.5); // conversion is expecting msec. Add a pad.
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// Move Z Axis to unload pos
axes[AD_Z].MoveParameters.Velocity := gr_CfgCurrent.zAxis.indexSpeed;
axes[AD_Z].MoveParameters.Position := gr_CfgCurrent.zAxis.loadUnloadPos;
axes[AD_Z].MoveParameters.Acceleration := gr_CfgCurrent.zAxis.accel;
axes[AD_Z].MoveParameters.Deceleration := gr_CfgCurrent.zAxis.decel;
axes[AD_Z].Commands.MoveAbsoluteReq := TRUE;

END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;

// Make sure Z Index info is up to date
CalcZIndex;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_ZToUnload TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION UnloadDone FROM Stp_ZToUnload TO Stp_CfOff2:=
(* @LANGUAGE := 'st' *)
// Request has been processed, and Z axis is stopped and in position
NOT axes[AD_Z].Commands.MoveAbsoluteReq AND
axes[AD_Z].Status.PlcOpenState = mcAXIS_STANDSTILL AND
axes[AD_Z].Status.IsInPosition
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CfOff2' *)
STEP Stp_CfOff2:
(* @LANGUAGE := 'st' *)
// Run step hold timer (PT set in step entry)
tmrStepMin(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_CF_OFF2;

// Reset step hold timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);

// Turn off CF pump -- won't work if pump is in manual mode
// TODO
//cfVfd.ReqAutoStop := TRUE;
END_ACTION
TRANSITION min time and cf stop req processed FROM Stp_CfOff2 TO Stp_DoneWait:=
(* @LANGUAGE := 'st' *)
// Min time
tmrStepMin.Q // AND
// Auto stop request was processed 
// TODO
// NOT cfVfd.ReqAutoStop 
END_TRANSITION
(* @SFCNOJUMP := 'Stp_DoneWait' *)
STEP Stp_DoneWait:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_DONE_WAIT;
// No longer in cycle
operatingMode.isInCycle := FALSE;
END_ACTION
TRANSITION FROM Stp_DoneWait TO Stp_ProdWaitForStart:=
TRUE
END_TRANSITION
(* @SFCISJUMP := 'Stp_ProdWaitForStart' *)
TRANSITION continue, idx dn, skip off CF FROM Stp_IndexZWait TO Stp_ZToUnload:=
(* @LANGUAGE := 'st' *)
// Normal indexing is done, and we want to keep the cutting fluid running while we go to unload
// Once continuing, go to unload, but consider single cycle include index or not
gr_PartCurrent.zIndexCount >= partMotion.totalIndexes AND
NOT operatingMode.ShutOffCfBeforeUnload AND
// Continue
// If in single cycle, continue if we want to include the index in the single cycle, 
// or if we don't but we get a start request. This allows the machine to stop before
// the index in single cycle, but then allows the operator to continue.

// Operating mode is continuous OR
// single cycle AND (incl index OR (dont' include index AND get a start press))
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
(operatingMode.SubMode = OM_PROD_SM_SINGLE AND // one cycle at a time
(operatingMode.SingleCycleInclZIndex OR (NOT operatingMode.SingleCycleInclZIndex AND operatingMode.ReqCycleStart))) OR // incl Z index, or initially don't but then get start req
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // One step at a time
END_TRANSITION
(* @SFCISJUMP := 'Stp_ZToUnload' *)
TRANSITION continue, next index FROM Stp_IndexZWait TO Stp_IndexZ:=
(* @LANGUAGE := 'st' *)
// Normal indexing is not done
gr_PartCurrent.zIndexCount < partMotion.totalIndexes AND
// Continue
// If in single cycle, continue if we want to include the index in the single cycle, 
// or if we don't but we get a start request. This allows the machine to stop before
// the index in single cycle, but then allows the operator to continue.

// Operating mode is continuous OR
// single cycle AND (incl index OR (dont' include index AND get a start press))
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
(operatingMode.SubMode = OM_PROD_SM_SINGLE AND // one cycle at a time
(operatingMode.SingleCycleInclZIndex OR (NOT operatingMode.SingleCycleInclZIndex AND operatingMode.ReqCycleStart))) OR // incl Z index, or initially don't but then get start req
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // One step at a time
END_TRANSITION
(* @SFCNOJUMP := 'Stp_IndexZ' *)
STEP Stp_IndexZ:
(* @LANGUAGE := 'st' *)
// Run step hold and timeout timers (PT set in step entry)
tmrStepMin(IN:= TRUE);
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_INDEX_Z;

// Reset step minimum timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);
// Reset TO tmr
// Set TO time to longer than is necessary for the move
// Use the trapazoidal move time fb to Calc PT time based on distance, velocity, accel, and decel.
// This should be a good approximate number, but not exact. It will be a bit low if jerk is used.
// Enforce a minimum time to rule out values <= 0
calcReal1 := 100.0; // in mSec when using the fb, 100 msec minimum
fbCalcMoveTimes(
  _I_Vel0 := 0.0,
_I_VelMove :=  gr_CfgCurrent.zAxis.indexSpeed,
_I_Accel := gr_CfgCurrent.zAxis.accel,
_I_Decel := gr_CfgCurrent.zAxis.decel,
_I_Dist := gr_CfgCurrent.zAxis.indexDist);

calcReal1 := MAX(calcReal1, DINT_TO_REAL(fbCalcMoveTimes._O_MoveTimeMsec)); // move time in msec
calcDint1 := REAL_TO_DINT(calcReal1 * 1.5); // conversion is expecting msec. Add a pad.
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// Index Z Axis
axes[AD_Z].MoveParameters.Velocity := gr_CfgCurrent.zAxis.indexSpeed;
axes[AD_Z].MoveParameters.Distance := gr_CfgCurrent.zAxis.indexDist;
axes[AD_Z].MoveParameters.Acceleration := gr_CfgCurrent.zAxis.accel;
axes[AD_Z].MoveParameters.Deceleration := gr_CfgCurrent.zAxis.decel;
axes[AD_Z].MoveParameters.Direction := mcDIR_POSITIVE;
axes[AD_Z].Commands.MoveRelativeReq := TRUE;

// Calculate the ZIndex Info
CalcZIndex;

END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;

// Make sure we have the latest Z Index info
CalcZIndex;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_IndexZ TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION min time and Index Done FROM Stp_IndexZ TO Stp_EOCWait:=
(* @LANGUAGE := 'st' *)
// min time expired
tmrStepMin.Q AND
// Request has been processed, and Z axis is stopped and in position
NOT axes[AD_Z].Commands.MoveRelativeReq AND
axes[AD_Z].Status.PlcOpenState = mcAXIS_STANDSTILL AND
axes[AD_Z].Status.IsInPosition
END_TRANSITION
(* @SFCNOJUMP := 'Stp_EOCWait' *)
STEP Stp_EOCWait:
(* @LANGUAGE := 'st' *)
// Run min step time tmr
tmrStepMin(IN:= FALSE, PT:= T#100ms);

// If the VFD is in auto, run a shutdown timer so we can turn off the cutting fluid
// if we sit here for too long. PT set at step entry.
// VFD could be in manual, in which case no moleste.
// TODO
// tmrCfShutoff(IN:= cfVfd.State = MTRVFD_REM_AUTO_RUN_FWD);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_EOC_WAIT;

// Reset step hold and timeout timers
tmrStepMin(IN:= FALSE, PT:= T#100ms);
tmrStepTO(IN:= FALSE, PT:= T#2s);

// Reset CF Shutoff Delay tmr
tmrCfShutoff(IN:= FALSE, PT:= gr_CfgCurrent.cfVfd.eocCutoutWaitTime);
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_EOCWait TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION cf shutoff FROM Stp_EOCWait TO Stp_CfTO:=
(* @LANGUAGE := 'st' *)
// Cutting fluid shutoff time expired
tmrCfShutoff.Q
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CfTO' *)
STEP Stp_CfTO:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_CF_TO;

// Time delay expired, turn off CF Pump
// TODO
// cfVfd.ReqAutoStop := TRUE; // won't work if pump is in manual mode
END_ACTION
TRANSITION cf stop req processed FROM Stp_CfTO TO Stp_EOCWait:=
(* @LANGUAGE := 'st' *)
// Auto stop request was processed 
// TODO
// NOT cfVfd.ReqAutoStop 
TRUE
END_TRANSITION
(* @SFCISJUMP := 'Stp_EOCWait' *)
TRANSITION min time and continue FROM Stp_EOCWait TO Stp_CycleHold7:=
(* @LANGUAGE := 'st' *)
// Min time expired
tmrStepMin.Q
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CycleHold7' *)
STEP Stp_CycleHold7:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION Stop Req FROM Stp_CycleHold7 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Stop Req
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION continue FROM Stp_CycleHold7 TO Stp_StartCf2:=
(* @LANGUAGE := 'st' *)
// Continue
// If in single cycle, the machine was stopped before the Z index if operatingMode.SingleCycleInclZIndex is clear,
// or it should stop now if operatingMode.SingleCycleInclZIndex, but not both.

// Operating mode is continuous OR
// (single cycle AND incl index AND get a start press) OR
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
  
(operatingMode.SubMode = OM_PROD_SM_SINGLE AND // one cycle at a time
operatingMode.SingleCycleInclZIndex AND // and include Z index
operatingMode.ReqCycleStart) OR // and start req
  
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // single step and start req
END_TRANSITION
(* @SFCNOJUMP := 'Stp_StartCf2' *)
STEP Stp_StartCf2:
(* @LANGUAGE := 'st' *)
// Run step hold timer (PT set in step entry)
tmrStepMin(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_START_CF2;

// Reset step hold timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);

// Set the vfd speed, and request start if not already running
// Request to start now, check for flow in a little bit.
// TODO
// cfVfd.ReqAutoSpeedEU := gr_CfgCurrent.cfVfd.speedPct;
// cfVfd.ReqAutoStart := cfVfd.State = MTRVFD_REM_AUTO_STOP;

END_ACTION
TRANSITION min time and req processed FROM Stp_StartCf2 TO Stp_NextCycle:=
(* @LANGUAGE := 'st' *)
// min time expired
tmrStepMin.Q // AND
// TODO
// NOT cfVfd.ReqAutoStart
END_TRANSITION
(* @SFCISJUMP := 'Stp_NextCycle' *)
TRANSITION finishing pass FROM Stp_AxesSynched TO Stp_SetFinishPass:=
(* @LANGUAGE := 'st' *)
// Cutting heads are synched and this is the last pass and there is no finising pass, or this is the finishing pass
// From the starting point, they will go a full revolution, plus an adjustment zone plus the cut overrun distance. Call this point T1.
// The next step is to calculate the next adjustment that will need to start at T1 and end after an adjustment angle.
// We will do this while running the cut, but we have to past the azimuth of the next adjustment point so the heads are
// forced to go all the way around before reaching this point again.
// The required distance was calculated earlier and stored in partMotion.calcNextAdjDistance
partMotion.passDistanceTraveled > partMotion.calcNextAdjDistance AND
  // This is the last pass, and there is no finishig pass, or there is a finishing pass, and it is finishing up -- time to set the inner eccentric to the retracted position
(gr_PartCurrent.cutPassCount = gr_CfgCurrent.cuttingHead.passCount AND
gr_CfgCurrent.cuttingHead.finishingPass)
END_TRANSITION
(* @SFCNOJUMP := 'Stp_SetFinishPass' *)
STEP Stp_SetFinishPass:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_SET_FINISH_PASS;

// Reset TO tmr
// The majority of the cut happens here -- the outer eccentric goes from the next adjustment point to the end of the pass position, 
// where a new sync cycle starts. This which will normally be nearly a full rotation, depending on the adj angle and overcut distance.
// The move should already be at velocity.
// Set TO time to longer than is necessary to travel the adj angle.
// Calc PT time based on velocity and travel distance -- which will be a bit low since it doesn't take accel into account
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, ((partMotion.passDistance - partMotion.passDistanceTraveled) / partMotion.cutVelocity)); // deg / deg/sec = sec
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// Finishg pass
// The pass is in progress, and a finishing pass is needed.
// While the cut is being made, set the Gear In Position parameters
// for the next pass.
// Some of the parameters were already set when the offset was established.
// Only set the changes here.

// Master position from which the slave moves synchronously at the new depth is the pass target position plus the adj angle
axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterSyncPosition := fctLRMod(partMotion.endOfPassPosition + partMotion.depthAdjAngle, 360.0);

// Slave position from which the slave moves synchronously is the master sync position, plus (the pass offset angle * pass count) + finish pass angle
axes[AD_OUTER_ECCENTRIC].CouplingParameters.SlaveSyncPosition := fctLRMod(axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterSyncPosition + (gr_CfgCurrent.cuttingHead.passCount * partMotion.depthAdjAngle) + partMotion.finishPassOffsetAngle, 360.0);

// Master start distance during which the slave synchronizes. Use the depth adj dist.
axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterStartDistance := partMotion.depthAdjAngle;

// trigger a param update
axes[AD_OUTER_ECCENTRIC].Commands.UpdateCouplingParams := TRUE;

// Update the end of pass position to reflect the new pass.
// This is the point where the pass has been made, including the overcut.
// Note the pass distance is the same as the previous passes, and was calculated at cycle start.
partMotion.endOfPassPosition := fctLRMod(partMotion.endOfPassPosition + partMotion.passDistance, 360.0);

// Calculate the azimuth when the next adjustment finishes.
// The next time around, the depth will be at the new depth or retracted when the outer eccentric gets to this point.
// The outer eccentric has to get past this point before a new adjustment is set up, so the heads are forced to go all
// the way around before reaching this point again.
partMotion.calcNextAdjPosition :=  fctLRMod(partMotion.endOfPassPosition + partMotion.depthAdjAngle, 360.0);
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_SetFinishPass TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION synching FROM Stp_SetFinishPass TO Stp_Synching3:=
(* @LANGUAGE := 'st' *)
// Make sure the update has been processed, and the
// inner axis is compensating -- being brought into sync at the specified positions.
// This is the start of bringing the cutting heads to finish pass depth.
NOT axes[AD_OUTER_ECCENTRIC].Commands.UpdateCouplingParams AND
axes[AD_OUTER_ECCENTRIC].Status.IsCoordInCompensation
END_TRANSITION
(* @SFCNOJUMP := 'Stp_Synching3' *)
STEP Stp_Synching3:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_SYNCHING3;
END_ACTION
TRANSITION FROM Stp_Synching3 TO Stp_IncrPassCount:=
TRUE
END_TRANSITION
(* @SFCNOJUMP := 'Stp_IncrPassCount' *)
STEP Stp_IncrPassCount:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Increment pass count
gr_PartCurrent.cutPassCount := gr_PartCurrent.cutPassCount  + 1;
END_ACTION
TRANSITION FROM Stp_IncrPassCount TO Stp_Synching1:=
TRUE
END_TRANSITION
(* @SFCISJUMP := 'Stp_Synching1' *)
TRANSITION addl pass FROM Stp_AxesSynched TO Stp_SetNextPass:=
(* @LANGUAGE := 'st' *)
// Cutting heads are synched and this is the last pass and there is no finising pass, or this is the finishing pass
// From the starting point, they will go a full revolution, plus an adjustment zone plus the cut overrun distance. Call this point T1.
// The next step is to calculate the next adjustment that will need to start at T1 and end after an adjustment angle.
// We will do this while running the cut, but we have to past the azimuth of the next adjustment point so the heads are
// forced to go all the way around before reaching this point again.
// The required distance was calculated earlier and stored in partMotion.calcNextAdjDistance
partMotion.passDistanceTraveled > partMotion.calcNextAdjDistance AND
// This is at least one more pass -- time to set the inner eccentric to the next pass depth position
gr_PartCurrent.cutPassCount  < gr_CfgCurrent.cuttingHead.passCount
END_TRANSITION
(* @SFCNOJUMP := 'Stp_SetNextPass' *)
STEP Stp_SetNextPass:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_SET_NEXT_PASS;

// Next pass
// The pass is in progress, and at least one more pass is needed.
// While the cut is being made, set the Gear In Position parameters
// for the next pass.
// Some of the parameters were already set when the offset was established.
// Only set the changes here.

// Master position from which the slave moves synchronously at the new depth is the pass target position plus the adj angle
axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterSyncPosition := fctLRMod(partMotion.endOfPassPosition + partMotion.depthAdjAngle, 360.0);

// Slave position from which the slave moves synchronously is the master sync position, plus (the pass offset angle * number of passes). Keep in 
// mind we are setting the depth for the next pass, and this one has not been completed yet, so the pass number is the current pass + 1
axes[AD_OUTER_ECCENTRIC].CouplingParameters.SlaveSyncPosition := fctLRMod(axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterSyncPosition + (partMotion.passOffsetAngle * (gr_PartCurrent.cutPassCount + 1)), 360.0);

// Master start distance during which the slave synchronizes. Use the depth adj dist.
axes[AD_OUTER_ECCENTRIC].CouplingParameters.MasterStartDistance := partMotion.depthAdjAngle;

// trigger a param update
axes[AD_OUTER_ECCENTRIC].Commands.UpdateCouplingParams := TRUE;

// Update the end of pass position to reflect the new pass.
// This is the point where the pass has been made, including the overcut.
// Note the pass distance is the same as the previous passes, and was calculated at cycle start.
partMotion.endOfPassPosition := fctLRMod(partMotion.endOfPassPosition + partMotion.passDistance, 360.0);

// Calculate the azimuth when the next adjustment finishes.
// The next time around, the depth will be at the new depth or retracted when the outer eccentric gets to this point.
// The outer eccentric has to get past this point before a new adjustment is set up, so the heads are forced to go all
// the way around before reaching this point again.
partMotion.calcNextAdjPosition :=  fctLRMod(partMotion.endOfPassPosition + partMotion.depthAdjAngle, 360.0);
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_SetNextPass TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION synching FROM Stp_SetNextPass TO Stp_Synching3:=
(* @LANGUAGE := 'st' *)
// Make sure the update has been processed, and the
// inner axis is compensating -- being brought into sync at the specified positions.
// This is the start of bringing the cutting heads to the next depth.
NOT axes[AD_OUTER_ECCENTRIC].Commands.UpdateCouplingParams AND
axes[AD_OUTER_ECCENTRIC].Status.IsCoordInCompensation
END_TRANSITION
(* @SFCISJUMP := 'Stp_Synching3' *)
TRANSITION min time zero depth need SOC FROM Stp_ZeroDepth TO Stp_CycleHold2:=
(* @LANGUAGE := 'st' *)
// Minimum time expired and inner axis is done moving and depth tolerance is good (depth ~0)
tmrStepMin.Q AND
axes[AD_INNER_ECCENTRIC].Status.IsInPosition AND axes[AD_INNER_ECCENTRIC].Status.PlcOpenState = mcAXIS_STANDSTILL AND // isMoveDone will get cleared when SM removes cmd
ABS(axes[AD_INNER_ECCENTRIC].Status.CalculatedPosition1) < TOL_DEPTH_ZERO_DEG AND
// Z-Axis is not indexed, and is below the start of the cut position.  
// Differentiate from being above the cut zone -- we don't want to come down from the load/unload position as part of a part cycle, as this may crash the head
// into the top of the workpiece.
// We need to get to the start of cut position
((NOT gr_PartCurrent.isZIndexed OR gr_PartCurrent.zIndexCount = 0) AND axes[AD_Z].Status.Position < gr_CfgCurrent.zAxis.startOfCutPos)
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CycleHold2' *)
STEP Stp_CycleHold2:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION Stop Req FROM Stp_CycleHold2 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Stop Req
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION continue FROM Stp_CycleHold2 TO Stp_ZToSOC:=
(* @LANGUAGE := 'st' *)
// Operating mode is continuous OR
// single cycle OR
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
operatingMode.SubMode = OM_PROD_SM_SINGLE OR // one cycle at a time
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // One step at a time
END_TRANSITION
(* @SFCNOJUMP := 'Stp_ZToSOC' *)
STEP Stp_ZToSOC:
(* @LANGUAGE := 'st' *)
// Run step hold and timeout timers (PT set in step entry)
tmrStepMin(IN:= TRUE);
tmrStepTO(IN:= TRUE);

// Calculate Z Index info
CalcZIndex;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_Z_TO_SOC;

// Reset step minimum timer
tmrStepMin(IN:= FALSE, PT:= T#100ms);
// Reset TO tmr
// Set TO time to longer than is necessary for the move
// Use the trapazoidal move time fb to Calc PT time based on distance, velocity, accel, and decel.
// This should be a good approximate number, but not exact. It will be a bit low if jerk is used.
// Enforce a minimum time to rule out values <= 0
calcReal1 := 100.0; // in mSec when using the fb, 100 msec minimum
fbCalcMoveTimes(
_I_Vel0 := 0.0,
_I_VelMove :=  gr_CfgCurrent.zAxis.indexSpeed,
_I_Accel := gr_CfgCurrent.zAxis.accel,
_I_Decel := gr_CfgCurrent.zAxis.decel,
_I_Dist := ABS(axes[AD_Z].Status.Position - gr_CfgCurrent.zAxis.startOfCutPos)); // FB needs a distance

calcReal1 := MAX(calcReal1, DINT_TO_REAL(fbCalcMoveTimes._O_MoveTimeMsec)); // move time in msec
calcDint1 := REAL_TO_DINT(calcReal1 * 1.5); // conversion is expecting msec. Add a pad.
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// Index Z Axis to SOC
axes[AD_Z].MoveParameters.Velocity := gr_CfgCurrent.zAxis.indexSpeed;
axes[AD_Z].MoveParameters.Position := gr_CfgCurrent.zAxis.startOfCutPos;
axes[AD_Z].MoveParameters.Acceleration := gr_CfgCurrent.zAxis.accel;
axes[AD_Z].MoveParameters.Deceleration := gr_CfgCurrent.zAxis.decel;
axes[AD_Z].MoveParameters.Direction := mcDIR_POSITIVE;
axes[AD_Z].Commands.MoveAbsoluteReq := TRUE;

END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;

// Make sure the latest index info is calculated
CalcZIndex;
END_ACTION
TRANSITION Step TO or Stop Req FROM Stp_ZToSOC TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Step timeout or cycle stop
tmrStepTO.Q OR
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION Z at SOC and cf good FROM Stp_ZToSOC TO Stp_CycleHold3:=
(* @LANGUAGE := 'st' *)
// min time expired
tmrStepMin.Q AND
// Request has been processed, and Z axis is stopped and in position
NOT axes[AD_Z].Commands.MoveAbsoluteReq AND
axes[AD_Z].Status.PlcOpenState = mcAXIS_STANDSTILL AND
axes[AD_Z].Status.IsInPosition AND
// At the first index position
gr_PartCurrent.isZIndexed AND
gr_PartCurrent.zIndexCount = 1 AND
// Cutting fluid pump is running and flow is good
cfVfd.isRunning AND
cfVfd.isFlowEstablished

END_TRANSITION
(* @SFCNOJUMP := 'Stp_CycleHold3' *)
STEP Stp_CycleHold3:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION Stop Req FROM Stp_CycleHold3 TO Stp_CycleStop:=
(* @LANGUAGE := 'st' *)
// Stop Req
operatingMode.ReqCycleStop
END_TRANSITION
(* @SFCISJUMP := 'Stp_CycleStop' *)
TRANSITION continue FROM Stp_CycleHold3 TO Stp_NextCycle:=
(* @LANGUAGE := 'st' *)
// Operating mode is continuous OR
// single cycle OR
// single step AND start req
operatingMode.SubMode = OM_PROD_SM_CONTINUOUS OR // run cycles until done or error
operatingMode.SubMode = OM_PROD_SM_SINGLE OR // one cycle at a time
(operatingMode.SubMode = OM_PROD_SM_STEPPED AND operatingMode.ReqCycleStart) // One step at a time
END_TRANSITION
(* @SFCISJUMP := 'Stp_NextCycle' *)
STEP Stp_CycleStop:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_CYCLE_STOP;

// Machine is stopping
operatingMode.isStopping := TRUE;
END_ACTION
TRANSITION FROM Stp_CycleStop TO Stp_CS_StopAxes:=
TRUE
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CS_StopAxes' *)
STEP Stp_CS_StopAxes:
(* @LANGUAGE := 'st' *)
// Run the TO timer (PT set in step entry).
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_CS_STOP_AXES;

// Reset TO tmr
// Set TO time to longer than is necessary for the stops to occur
// Calc PT time based on velocity and decel, and set the PT based on the axis which should take longest to stop,
// but enforce a minimum time to rule out values <= 0
calcReal1 := 0.1; // 100 msec minimum
calcReal1 := MAX(calcReal1, (ABS(axes[AD_Z].Status.Velocity) / axes[AD_Z].MoveParameters.Deceleration)); // mm/sec * sec^2/mm = sec
calcReal1 := MAX(calcReal1, (ABS(axes[AD_OUTER_ECCENTRIC].Status.Velocity) / axes[AD_OUTER_ECCENTRIC].MoveParameters.Deceleration));
calcReal1 := MAX(calcReal1, (ABS(axes[AD_INNER_ECCENTRIC].Status.Velocity) / axes[AD_INNER_ECCENTRIC].MoveParameters.Deceleration));
calcDint1 := REAL_TO_DINT(calcReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// Halt Z
axes[AD_Z].Commands.HaltReq := TRUE;
// Halt the eccentrics and decouple inner (which halt will also do), but make sure the coupling cmd is false.
axes[AD_OUTER_ECCENTRIC].Commands.HaltReq := TRUE;
axes[AD_INNER_ECCENTRIC].Commands.HaltReq := TRUE;
axes[AD_INNER_ECCENTRIC].CouplingParameters.GearInCmd := FALSE;

END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;

// Make sure the latest index info is calculated
CalcZIndex;
END_ACTION
TRANSITION Z, OutE, InE  stopped or TO FROM Stp_CS_StopAxes TO Stp_CS_ZeroDepth:=
(* @LANGUAGE := 'st' *)
// In cycle stop sequence, we don't want hangups.
// Proceed if the halt req was processed and the axes stop or a step TO occurs
(NOT axes[AD_Z].Commands.HaltReq AND
NOT axes[AD_OUTER_ECCENTRIC].Commands.HaltReq AND
NOT axes[AD_INNER_ECCENTRIC].Commands.HaltReq AND
(axes[AD_Z].Status.IsStopped AND
axes[AD_Z].Status.PlcOpenState <> mcAXIS_DISCRETE_MOTION) AND
(axes[AD_OUTER_ECCENTRIC].Status.IsStopped AND
axes[AD_OUTER_ECCENTRIC].Status.PlcOpenState <> mcAXIS_DISCRETE_MOTION AND// cover the abs and rel moves
axes[AD_OUTER_ECCENTRIC].Status.PlcOpenState <> mcAXIS_CONTINUOUS_MOTION) AND // cover the vel moves
(axes[AD_INNER_ECCENTRIC].Status.IsStopped AND
axes[AD_INNER_ECCENTRIC].Status.PlcOpenState <> mcAXIS_DISCRETE_MOTION AND // cover the abs and rel moves
axes[AD_INNER_ECCENTRIC].Status.PlcOpenState <> mcAXIS_CONTINUOUS_MOTION AND // cover the vel moves
axes[AD_INNER_ECCENTRIC].Status.PlcOpenState <> mcAXIS_SYNCHRONIZED_MOTION)) OR // cover coord moves
tmrStepTO.Q
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CS_ZeroDepth' *)
STEP Stp_CS_ZeroDepth:
(* @LANGUAGE := 'st' *)
// Run the TO timer (PT set in step entry).
tmrStepTO(IN:= TRUE);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_CS_ZERO_DEPTH;

// Reset TO tmr
// Set TO time to longer than is necessary for the move
// Calc PT time based on distance and velocity, which will be a bit low since it does not take into account accel and decel.
// Enforce a minimum time to rule out values <= 0
calcLReal1 := 0.1; // 100 msec minimum
calcLReal1 := MAX(calcLReal1, (ABS(axes[AD_INNER_ECCENTRIC].Status.CalculatedPosition1) / gr_CfgCurrent.cuttingHead.retractRate)); // deg / deg/sec = sec 
calcDint1 := LREAL_TO_DINT(calcLReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// Run inner eccentric back to zero depth. The "zero" depth spot moves with the outer eccentric,
// so do a relative move back by the angular difference to the outer eccentric axis.
// This assumes the zero/home position of both the Outer and Inner axes was set to zero when
// the index lines are lined up with each other.
// For the inner axis, the angular difference to the outer eccentric is stored in CalculatedPosition1
axes[AD_INNER_ECCENTRIC].MoveParameters.Distance := (-1.0 * axes[AD_INNER_ECCENTRIC].Status.CalculatedPosition1);
// Use the retract velocity
axes[AD_INNER_ECCENTRIC].MoveParameters.Velocity := gr_CfgCurrent.cuttingHead.retractRate; // deg/sec
axes[AD_INNER_ECCENTRIC].MoveParameters.Acceleration := gr_CfgCurrent.cuttingHead.accel;
axes[AD_INNER_ECCENTRIC].MoveParameters.Deceleration := gr_CfgCurrent.cuttingHead.decel;
axes[AD_INNER_ECCENTRIC].Commands.MoveRelativeReq := TRUE;



END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION InE stopped or TO FROM Stp_CS_ZeroDepth TO Stp_CS_StopSpindle:=
(* @LANGUAGE := 'st' *)
// In cycle stop sequence, we don't want hangups.
// Proceed if the request is handled, and the axis is stopped or if a step TO occurs
(NOT axes[AD_INNER_ECCENTRIC].Commands.MoveRelativeReq AND 
axes[AD_INNER_ECCENTRIC].Status.IsStopped AND
axes[AD_INNER_ECCENTRIC].Status.PlcOpenState <> mcAXIS_DISCRETE_MOTION) OR // discrete move was used
tmrStepTO.Q
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CS_StopSpindle' *)
STEP Stp_CS_StopSpindle:
(* @LANGUAGE := 'st' *)
// Run the TO timer (PT set in step entry).
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_CS_STOP_SPINDLE;

// Set TO time to longer than is necessary for the stop to occur
// Calc PT time based on velocity and decel,
// but enforce a minimum time to rule out values <= 0
calcReal1 := 0.1; // 100 msec minimum
calcReal1 := MAX(calcReal1, (axes[AD_SPINDLE].Status.Velocity / axes[AD_SPINDLE].MoveParameters.Deceleration)); // mm/sec * sec^2/mm = sec
calcDint1 := REAL_TO_DINT(calcReal1 * 1000.0 * 1.5); // conversion is expecting msec
tmrStepTO.PT := DINT_TO_TIME(calcDint1);
tmrStepTO(IN:= FALSE); 

// Stop the spindle
axes[AD_SPINDLE].Commands.HaltReq := TRUE;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;
END_ACTION
TRANSITION Spindle stopped or TO FROM Stp_CS_StopSpindle TO Stp_DisableAxes:=
(* @LANGUAGE := 'st' *)
// In cycle stop sequence, we don't want hangups.
// Proceed if the halt req was processed and the axis stops or a step TO occurs
(NOT axes[AD_SPINDLE].Commands.HaltReq AND
axes[AD_SPINDLE].Status.IsStopped AND
axes[AD_SPINDLE].Status.PlcOpenState <> mcAXIS_CONTINUOUS_MOTION) OR // spindle uses vel move 
tmrStepTO.Q
END_TRANSITION
(* @SFCNOJUMP := 'Stp_DisableAxes' *)
STEP Stp_DisableAxes:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_CS_DISABLE_AXES;

// Disable axes
axes[AD_SPINDLE].Commands.DisableReq := TRUE;
axes[AD_INNER_ECCENTRIC].Commands.DisableReq := TRUE;
axes[AD_OUTER_ECCENTRIC].Commands.DisableReq := TRUE;
axes[AD_Z].Commands.DisableReq := TRUE;
END_ACTION
TRANSITION FROM Stp_DisableAxes TO Stp_CS_StopCF:=
TRUE
END_TRANSITION
(* @SFCNOJUMP := 'Stp_CS_StopCF' *)
STEP Stp_CS_StopCF:
(* @LANGUAGE := 'st' *)
// Run step TO timer (PT set in step entry)
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_CS_STOP_CF;

// Reset TO timer. Pick a time that is longer than the stop should take.
tmrStepTO(IN:= FALSE, PT:= T#5s);
// Turn off CF pump 
// TODO
// cfVfd.ReqAutoStop := TRUE;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// The current step holds an ePROD_CYCLE_STEP enum which also 
// acts as the array index.

// Record the ET
stepETs[partMotion.prodCycleStepCurrent] := tmrStepTO.ET;
// If this is a timeout, record that also
stepIsTO[partMotion.prodCycleStepCurrent] := tmrStepTO.Q;

// machine is no longer in cycle or stopping -- it is stopped
operatingMode.isInCycle := FALSE;
operatingMode.isStopping := FALSE;
END_ACTION
TRANSITION vfd stopped or TO FROM Stp_CS_StopCF TO Stp_ProdWaitForStart:=
(* @LANGUAGE := 'st' *)
// Stop req is processed and VFD is stopped,
// or the step times out
// TODO
// (NOT cfVfd.ReqAutoStop AND cfVfd.isRunning) OR
tmrStepTO.Q
END_TRANSITION
(* @SFCISJUMP := 'Stp_ProdWaitForStart' *)
STEP Stp_WaitForProd:
(* @LANGUAGE := 'st' *)
// These calcs will put results in the local partMotion structure.
// Do these calcs now so they are known before hand, and can be displayed now
// and used later.
CalcPartMotion;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Update step 
partMotion.prodCycleStepCurrent := PCS_WAIT_FOR_PROD;

// Clear in cycle bit to safety PLC
ts_InCycle := FALSE;

// Unlock the cutting fluid gate when not in cycle
ts_cfLockGate := FALSE;
END_ACTION
TRANSITION in prod mode FROM Stp_WaitForProd TO Stp_ProdWaitForStart:=
(* @LANGUAGE := 'st' *)
// In production mode
operatingMode.OperatingMode = OM_PRODUCTION_MODE
END_TRANSITION
(* @SFCISJUMP := 'Stp_ProdWaitForStart' *)
END_PROGRAM
