PROGRAM _CYCLIC
<?AutomationStudio FileVersion="4.9"?>
INITIAL_STEP Step_Initial:
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_INITIAL;

// Most stuff initialized in the AxSMInit.st routine

// init drive reset delay timer
tmrDriveReset.PT:= T#5s;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Step_Initial TO Step_Ignore_Axis:=
TRUE
END_TRANSITION
(* @SFCNOJUMP := 'Step_Ignore_Axis' *)
STEP Step_Ignore_Axis:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_IGNORE;

END_ACTION
TRANSITION FROM Step_Ignore_Axis TO Step_AxisValid_Check:=
NOT ax.Ignore
END_TRANSITION
(* @SFCNOJUMP := 'Step_AxisValid_Check' *)
STEP Step_AxisValid_Check:
(* @LANGUAGE := 'st' *)
// Clear the commands and run MpAxisBasic to get status
// From this state, you can only get to the ignore, disable, or error states,
// but the transition to ignore, disable, or error happens without operator requests,
// so no need to consider any requests.

fctClearMotionCommands(_I_CmdMask := MACM_NOMASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_NOMASK, _IO_Commands := ax.Commands);
ActionCallMotionFunctions;

// If the axis in invalid, periodically run the fb with the input disabled to 
// force a rising edge the next time.
tmrDriveReset(IN:= ax.statusFpMpAxisBasic.StatusId <> mcAXIS_NO_ERROR AND NOT tmrDriveReset.Q);
IF (tmrDriveReset.Q) THEN
  ax.fbMpAxisBasic(Enable:= FALSE);
END_IF;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_VALID_CHECK;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Reset the drive reset timer
tmrDriveReset(IN:= FALSE);
END_ACTION
TRANSITION FROM Step_AxisValid_Check TO Step_Ignore_Axis:=
ax.Ignore
END_TRANSITION
(* @SFCISJUMP := 'Step_Ignore_Axis' *)
TRANSITION Reset Req FROM Step_AxisValid_Check TO Step_Error_DriveReset:=
(* @LANGUAGE := 'st' *)
// Drive reset request
ax.Commands.DriveResetReq

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_DriveReset' *)
TRANSITION Valid and no errors FROM Step_AxisValid_Check TO Step_Disabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), and no errors
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error
END_TRANSITION
(* @SFCNOJUMP := 'Step_Disabled' *)
STEP Step_Disabled:
(* @LANGUAGE := 'st' *)
// From the disabled state, you can only get to
// the Ready (enabled/powered), Home, Error, or drive reset states,
// but this state does not send any commands, except for the brake release if requested.
// Clear all the commands except for brake release.
// Allow the Enable, Brake Release, Home, and Reset requests
// Note: The brake release is only valid in this state. This command will get cleared when leaving this state
// If axis is virtual, don't allow brake release
IF ax.isAxisVirtual THEN
  cmdMask := MACM_NOMASK;
  fctClearMotionCommands(_I_CmdMask := cmdMask, _IO_Commands := ax.Commands);
ELSE
  // non-virtual axis ... allow brake release if requested
  cmdMask := MACM_RELEASE_BRAKE_MASK;
  fctClearMotionCommands(_I_CmdMask := cmdMask, _IO_Commands := ax.Commands);
  // Set the release brake command if requested. Give priority to the clear cmd.
  IF  ax.Commands.ClearReleaseBrakeReq THEN
    ax.Commands.ReleaseBrakeCmd := FALSE;
  ELSIF ax.Commands.ReleaseBrakeReq THEN
    ax.Commands.ReleaseBrakeCmd := TRUE;
  END_IF;
END_IF;
  
// Call motion command to get status and possibly release the brake
ActionCallMotionFunctions;

// Clear the requests other than the enable, home, and drive reset
// The brake release was already handled above, so it is okay (necessary) to clear the req now.
reqMask := MACM_ENABLE_MASK + MACM_HOME_MASK + MACM_DRIVE_RESET_MASK;
fctClearMotionRequests(_I_ReqMask := reqMask, _IO_Commands := ax.Commands);

// Run the mode mismatch timer if the mode is not ok.
// Assume mode is okay - no modes on this system
tmrModeMismatch(IN:= FALSE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := 'Waiting for Power' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_DISABLED;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// On exit, clear the the brake release cmd and requests since they are only valid in this state.
ax.Commands.ReleaseBrakeReq := FALSE;
ax.Commands.ClearReleaseBrakeReq := FALSE;
ax.Commands.ReleaseBrakeCmd := FALSE;
END_ACTION
TRANSITION FROM Step_Disabled TO Step_Ignore_Axis:=
ax.Ignore
END_TRANSITION
(* @SFCISJUMP := 'Step_Ignore_Axis' *)
TRANSITION Invalid Status FROM Step_Disabled TO Step_AxisValid_Check:=
(* @LANGUAGE := 'st' *)
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_ACTIVATION OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_NULL OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_INVALID OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CHANGED OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CORRUPT OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_IN_USE OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PAR_NULL
END_TRANSITION
(* @SFCISJUMP := 'Step_AxisValid_Check' *)
TRANSITION Mode problem FROM Step_Disabled TO Step_Disabled:=
(* @LANGUAGE := 'st' *)
// mode mismatch timer times out
tmrModeMismatch.Q
END_TRANSITION
(* @SFCISJUMP := 'Step_Disabled' *)
TRANSITION no errors, reset req FROM Step_Disabled TO Step_Error_DriveReset:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors, drive reset req
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Commands.DriveResetReq
END_TRANSITION
(* @SFCISJUMP := 'Step_Error_DriveReset' *)
TRANSITION valid but error FROM Step_Disabled TO Step_Error_DrvRstWait:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION
END_TRANSITION
(* @SFCISJUMP := 'Step_Error_DrvRstWait' *)
TRANSITION no errors, home req FROM Step_Disabled TO Stp_BrakeRel1:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors, home request
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Commands.HomeReq
END_TRANSITION
(* @SFCNOJUMP := 'Stp_BrakeRel1' *)
STEP Stp_BrakeRel1:
(* @LANGUAGE := 'st' *)
// On the way to homeing, but not there yet ... Need to make sure the manual brake release is off
// Clear all the commands.
// Allow the Home request since that is where we are going
fctClearMotionCommands(_I_CmdMask := MACM_NOMASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_HOME_MASK, _IO_Commands := ax.Commands);

// Call motion command to get status and possibly release the brake
ActionCallMotionFunctions;

// Run step TO timer
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Reset step TO tmr
tmrStepTO(IN:= FALSE, PT:= T#500ms);
END_ACTION
TRANSITION brake off or TO FROM Stp_BrakeRel1 TO Step_HomeReq:=
(* @LANGUAGE := 'st' *)
// Manual brake release should turn off, but don't allow us to get stuck here.
// Errors will be caught once in the home state.
(NOT ax.Commands.ReleaseBrakeReq AND
NOT ax.Commands.ReleaseBrakeCmd AND
NOT ax.Status.IsBrakeManuallyReleased)
OR
tmrStepTO.Q
END_TRANSITION
(* @SFCISJUMP := 'Step_HomeReq' *)
TRANSITION no errors, global or axis enable req FROM Step_Disabled TO Stp_BrakeRel2:=
(* @LANGUAGE := 'st' *)
// // Valid status (allow the couple axis warnings), no errors and enable req or global enable req
// TODO: How to deal with handling global request (local OS or some sort or reset of cmd)
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
(ax.Commands.EnableReq OR gMotionCommands.EnableReq)
END_TRANSITION
(* @SFCNOJUMP := 'Stp_BrakeRel2' *)
STEP Stp_BrakeRel2:
(* @LANGUAGE := 'st' *)
// On the way to enable, but not there yet ... Need to make sure the manual brake release is off
// Clear all the commands.
// Allow the Enable request since that is where we are going
fctClearMotionCommands(_I_CmdMask := MACM_NOMASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_ENABLE_MASK, _IO_Commands := ax.Commands);

// Call motion command to get status and possibly release the brake
ActionCallMotionFunctions;

// Run step TO timer
tmrStepTO(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Reset step TO tmr
tmrStepTO(IN:= FALSE, PT:= T#500ms);
END_ACTION
TRANSITION brake off or TO FROM Stp_BrakeRel2 TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// Manual brake release should turn off, but don't allow us to get stuck here.
// Errors will be caught once in the enable state.
(NOT ax.Commands.ReleaseBrakeReq AND
NOT ax.Commands.ReleaseBrakeCmd AND
NOT ax.Status.IsBrakeManuallyReleased)
OR
tmrStepTO.Q
END_TRANSITION
(* @SFCNOJUMP := 'Step_Enabled' *)
STEP Step_Enabled:
(* @LANGUAGE := 'st' *)
// From the enabled state, you get to 
// the error, home, stop, halt, engage, move or disabled states.
// This state will honor the above listed requests.
// This state will send a power command.
// You might get here from another move command if a move request comes in for a move during another move,
// so to prevent a bump when honoring a new move request, don't indiscriminently clear the commands.
ax.Commands.EnableCmd := TRUE;

// Jog no used with MpAxisBasic. Velocity move or jog positive limit or jog negative limit used in place of jog.
// Replace a jog request with a velocity req. Jog positive limit and jog negative limit are handled as
// stand alone requests.
ax.Commands.MoveVelocityReq := ax.Commands.MoveVelocityReq OR ax.Commands.MoveJogReq;
ax.Commands.MoveJogReq := FALSE;
ax.Commands.MoveJogCmd := FALSE;

// Initialize the req mask. This will be used at the bottom to clear the other (unwanted) requests.
// In between, however, allowed requests may modify the mask.
// Note that motion realted requests are ignored for vitual axes.
IF ax.isAxisVirtual THEN
  // For a vitual axis, set the mask to ignore the motion requests, and don't qualify the move requests.
  reqMask := MACM_DISABLE_MASK + MACM_HOME_MASK;
ELSE
  // Non virtual axis ... handle the move requests.
  // Initial mask that may get altered depeding on move request
  reqMask := MACM_DISABLE_MASK + MACM_HOME_MASK + MACM_STOP_MASK + MACM_HALT_MASK;
  
  // Qualify move requests
  // Upon a request, check permissives.
  // If the not allowed flag is clear, then allow the move
  // and clear the other requests. 
  // The order of the request checks give priority as follows
  // jog, jog limit positive, jog limit negative, velocity, relative, absolute, engage slave, disengage slave
  // The above priority is somewhat arbitrary, but an order was needed, because only one
  // move is allowed, and each move clears the other requests.  There may be a better/more sensical priority, however.

  // Jog Command
  IF ax.Commands.MoveJogReq THEN
    ActionChkPermissiveContinuous; 
    IF (ax.Commands.MoveNotAllowed OR NOT ax.Status.IsHomed OR ax.ForceSetRef) THEN
      // Move not allowed in requested direction or axis is not homed, or it needs to be re-referenced
      // Set the mask to clear the request, preserving disable, halt and stop reqs
      // Mask set above, nothing to do
      // reqMask := MACM_DISABLE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;
      ;
    ELSE
      // Move allowed, leave the request
      // Modify the mask set above, and clear the other move requests, preserving disable, halt and stop reqs
      reqMask := reqMask + MACM_JOG_MASK;
    END_IF
  END_IF
  
  // Jog Positive Limit Request
  // Jog Limit requires move permissives.  The FB
  // checks the position window, so this is a duplication of the
  // application position window check.
  IF ax.Commands.MoveJogPositiveReq THEN
    ActionChkPermissiveContinuous; 
    IF (ax.Commands.MoveNotAllowed OR NOT ax.Status.IsHomed OR ax.ForceSetRef) THEN
      // Move not allowed in requested direction or axis is not homed, or it needs to be re-referenced
      // Set the mask to clear the request, preserving disable, halt and stop reqs
      // Mask set above, nothing to do
      // reqMask := MACM_DISABLE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;
      ;
    ELSE
      // Move allowed, leave the request
      // Modify the mask set above, and clear the other move requests, preserving disable, halt and stop reqs
      reqMask := reqMask + MACM_JOG_POSITIVE_MASK;
    END_IF
  END_IF
      
  // Jog Negative Limit Request
  // Jog Limit requires move permissives.  The FB
  // checks the position window, so this is a duplication of the
  // application position window check.
  IF ax.Commands.MoveJogNegativeReq THEN
    ActionChkPermissiveContinuous; 
    IF (ax.Commands.MoveNotAllowed OR NOT ax.Status.IsHomed OR ax.ForceSetRef) THEN
      // Move not allowed in requested direction or axis is not homed, or it needs to be re-referenced
      // Set the mask to clear the request, preserving disable, halt and stop reqs
      // Mask set above, nothing to do
      // reqMask := MACM_DISABLE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;
      ;
    ELSE
      // Move allowed, leave the request
      // Modify the mask set above, and clear the other move requests, preserving disable, halt and stop reqs
      reqMask := reqMask + MACM_JOG_NEGATIVE_MASK;
    END_IF
  END_IF

  // Move Velocity Request
  IF ax.Commands.MoveVelocityReq THEN
    // Take a snapshot of the current position.
    // This is to allow permissive checking while on the move
    // and while supporting a changealbe move window
    ax.MoveParameters.PermissiveCheck.StartPosition:= ax.Status.Position;
    ActionChkPermissiveRel;
    IF (ax.Commands.MoveNotAllowed OR NOT ax.Status.IsHomed OR ax.ForceSetRef) THEN
      // Move not allowed in requested direction or axis is not homed, or it needs to be re-referenced
      // Set the mask to clear the request, preserving disable, halt and stop reqs
      // Mask set above, nothing to do
      // reqMask := MACM_DISABLE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;
      ;
    ELSE
      // Move allowed, leave the request
      // Modify the mask set above, and clear the other move requests, preserving disable, halt and stop reqs
      reqMask := reqMask + MACM_VELOCITY_MOVE_MASK;
    END_IF
  END_IF
  
  // Move Relative Request
  IF ax.Commands.MoveRelativeReq THEN
    // Take a snapshot of the current position.
    // This is to allow permissive checking while on the move
    // and while supporting a changealbe move window
    ax.MoveParameters.PermissiveCheck.StartPosition:= ax.Status.Position;
    ActionChkPermissiveRel;    
    IF (ax.Commands.MoveNotAllowed OR NOT ax.Status.IsHomed OR ax.ForceSetRef) THEN
      // Move not allowed in requested direction or axis is not homed, or it needs to be re-referenced
      // Set the mask to clear the request, preserving disable, halt and stop reqs
      // Mask set above, nothing to do
      // reqMask := MACM_DISABLE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;
      ;
    ELSE
      // Move allowed, leave the request
      // Modify the mask set above, and clear the other move requests, preserving disable, halt and stop reqs
      reqMask := reqMask + MACM_RELATIVE_MOVE_MASK;
    END_IF
  END_IF

  // Move Absolute Request
  IF ax.Commands.MoveAbsoluteReq THEN
    ActionChkPermissiveAbs;    
    IF (ax.Commands.MoveNotAllowed OR NOT ax.Status.IsHomed OR ax.ForceSetRef) THEN
      // Move not allowed in requested direction or axis is not homed, or it needs to be re-referenced
      // Set the mask to clear the request, preserving disable, halt and stop reqs
      // Mask set above, nothing to do
      // reqMask := MACM_DISABLE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;
      ;
    ELSE
      // Move allowed, leave the request
      // Modify the mask set above, and clear the other move requests, preserving disable, halt and stop reqs
      reqMask := reqMask + MACM_ABSOLUTE_MOVE_MASK;
    END_IF
  END_IF
END_IF;

// Clear the requests based on the mask set above
fctClearMotionRequests(_I_ReqMask := reqMask, _IO_Commands := ax.Commands);

// Call motion command to get status and enable the axis
ActionCallMotionFunctions;

// Run the mode mismatch timer if the mode is not ok.
// Assume mode is okay - no modes on this system
tmrModeMismatch(IN:= FALSE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := 'Power On and wait for a command' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_ENABLED;

// reset the mode mismatch timer
tmrModeMismatch(IN:= FALSE);
END_ACTION
TRANSITION FROM Step_Enabled TO Step_Ignore_Axis:=
ax.Ignore
END_TRANSITION
(* @SFCISJUMP := 'Step_Ignore_Axis' *)
TRANSITION Invalid Status FROM Step_Enabled TO Step_AxisValid_Check:=
(* @LANGUAGE := 'st' *)
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_ACTIVATION OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_NULL OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_INVALID OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CHANGED OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CORRUPT OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_IN_USE OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PAR_NULL

END_TRANSITION
(* @SFCISJUMP := 'Step_AxisValid_Check' *)
TRANSITION global or axis stop req FROM Step_Enabled TO Step_StopReq:=
(* @LANGUAGE := 'st' *)
// Global or axis Stop Request
// Note these may be attempted even if there is an error
// as errors are not checked before this.
ax.Commands.StopReq OR gMotionCommands.StopReq
END_TRANSITION
(* @SFCNOJUMP := 'Step_StopReq' *)
STEP Step_StopReq:
(* @LANGUAGE := 'st' *)
// From the stop state you can only leave with a stop reset req, or an error of some sort.
// Excert the stop cmd, the enable cmd, and preserve the stop reset req.
// Preserve the disable request -- this allows disableing after stopping.
ax.Commands.EnableCmd := TRUE;
ax.Commands.StopCmd := TRUE;
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_STOP_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_DISABLE_MASK + MACM_STOP_RESET_MASK, _IO_Commands := ax.Commands);

// Set the stop params using the values in the move params.
// Stop and halt are now implemented in a similar way, but Stop uses max decel, and forces a reset after.
// For a stop, until the reset is received, the stop cmd is exerted, and the axis state will stay in the Stopping state.
// Halt uses normal decel, and transitions back to enable after the axis is stopped.
// Halt is meant for a 'normal' process stop. Stop is meant for cases where intervention (a reset) should be forced.
ax.MoveParameters.StopParams.Deceleration := ax.MoveParameters.DecelMax;
ax.MoveParameters.StopParams.Jerk := 0.0;
// Stop at position isn't needed, but expose the params here and guess at logical defaults in case they are needed in the future.
ax.MoveParameters.StopParams.StopAtPosition.Activate := FALSE;
ax.MoveParameters.StopParams.StopAtPosition.Deceleration := ax.MoveParameters.Deceleration;
ax.MoveParameters.StopParams.StopAtPosition.Position := ax.MoveParameters.Position;

// Call motion command to get status, and issue the stop and enable commands.
ActionCallMotionFunctions;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_STOP;
END_ACTION
TRANSITION Invalid Status FROM Step_StopReq TO Step_AxisValid_Check:=
(* @LANGUAGE := 'st' *)
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_ACTIVATION OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_NULL OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_INVALID OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CHANGED OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CORRUPT OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_IN_USE OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PAR_NULL
END_TRANSITION
(* @SFCISJUMP := 'Step_AxisValid_Check' *)
TRANSITION error FROM Step_StopReq TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION stopped, reset req, no errors FROM Step_StopReq TO Step_Stop_Reset:=
(* @LANGUAGE := 'st' *)
// No errors and drive is stopped, in the standstill state, and a reset req was made
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Status.PlcOpenState = mcAXIS_STOPPING AND // state will remain in Stopping unitl stop cmd is removed
ax.Status.IsStopped AND
ax.Commands.StopResetReq
END_TRANSITION
(* @SFCNOJUMP := 'Step_Stop_Reset' *)
STEP Step_Stop_Reset:
(* @LANGUAGE := 'st' *)
// Clear the commands and requests, but preserve the enable cmd to keep from 
// turning off the axis.
ax.Commands.EnableCmd := TRUE;
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_NOMASK, _IO_Commands := ax.Commands);

// Call motion command to get status, and issue the enable command.
ActionCallMotionFunctions;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_STOP_RESET;
END_ACTION
TRANSITION FROM Step_Stop_Reset TO Step_Enabled:=
TRUE
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION global or axis halt req FROM Step_Enabled TO Step_HaltReq:=
(* @LANGUAGE := 'st' *)
// Global or axis Stop Request
// Note these may be attempted even if there is an error
// as errors are not checked before this.
ax.Commands.HaltReq OR gMotionCommands.HaltReq

END_TRANSITION
(* @SFCNOJUMP := 'Step_HaltReq' *)
STEP Step_HaltReq:
(* @LANGUAGE := 'st' *)
// From the halt state you can only leave with an error of some sort, or it leaves once the axis stops and goes to the enabled state.
// Excert the stop cmd, and the the enable cmd.
// Preserve the disable request -- this allows disableing after stopping.
ax.Commands.EnableCmd := TRUE;
ax.Commands.StopCmd := TRUE;
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_STOP_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_DISABLE_MASK, _IO_Commands := ax.Commands);

// Set the stop params using the values in the move params.
// Stop and halt are now implemented in a similar way, but Stop uses max decel, and forces a reset after.
// For a stop, until the reset is received, the stop cmd is exerted, and the axis state will stay in the Stopping state.
// Halt uses normal decel, and transitions back to enable after the axis is stopped.
// Halt is meant for a 'normal' process stop. Stop is meant for cases where intervention (a reset) should be forced.
ax.MoveParameters.StopParams.Deceleration := ax.MoveParameters.Deceleration;
ax.MoveParameters.StopParams.Jerk := 0.0;
// Stop at position isn't needed, but expose the params here and guess at logical defaults in case they are needed in the future.
ax.MoveParameters.StopParams.StopAtPosition.Activate := FALSE;
ax.MoveParameters.StopParams.StopAtPosition.Deceleration := ax.MoveParameters.Deceleration;
ax.MoveParameters.StopParams.StopAtPosition.Position := ax.MoveParameters.Position;

// Call motion command to get status, and issue the stop and enable commands.
ActionCallMotionFunctions;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_HALT;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Clear the commands and requests, but preserve the enable cmd to keep from 
// turning off the axis.
// Preserve the disable request -- this allows disableing after stopping.
ax.Commands.EnableCmd := TRUE;
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_DISABLE_MASK, _IO_Commands := ax.Commands);
// Call motion command to get status, and issue the enable command.
ActionCallMotionFunctions;
END_ACTION
TRANSITION Invalid Status FROM Step_HaltReq TO Step_AxisValid_Check:=
(* @LANGUAGE := 'st' *)
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_ACTIVATION OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_NULL OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_INVALID OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CHANGED OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CORRUPT OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_IN_USE OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PAR_NULL
END_TRANSITION
(* @SFCISJUMP := 'Step_AxisValid_Check' *)
TRANSITION error FROM Step_HaltReq TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION
END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION axis stopped, no errors FROM Step_HaltReq TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// No errors and drive is at a standstill.
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Status.PlcOpenState = mcAXIS_STOPPING AND // state will remain in Stopping unitl stop cmd is removed
ax.Status.IsStopped  // once stoped, we can leave
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid and global or axis disable req FROM Step_Enabled TO Step_Disabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and global or axis disable req
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
(ax.Commands.DisableReq OR gMotionCommands.DisableReq)
END_TRANSITION
(* @SFCISJUMP := 'Step_Disabled' *)
TRANSITION valid but error FROM Step_Enabled TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION
END_TRANSITION
(* @SFCNOJUMP := 'Step_Error_Stop' *)
STEP Step_Error_Stop:
(* @LANGUAGE := 'st' *)
// Exert a stop command and preserve the enable command.
// The axis may or may not be enabled (powered) depending on the error,
// but if it is enabled, don't presume we want it disabled.
// Clear the requests.
ax.Commands.StopCmd := TRUE;
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_STOP_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_NOMASK, _IO_Commands := ax.Commands);

// Set the stop params using the values in the move params.
// Stop and halt are now implemented in a similar way, but Stop uses max decel, and forces a reset after.
// Halt uses normal decel, and transitions back to enable after the axis is stopped.
// Halt is meant for a 'normal' process stop. Stop is meant for cases where intervention should be forced.
ax.MoveParameters.StopParams.Deceleration := ax.MoveParameters.DecelMax;
ax.MoveParameters.StopParams.Jerk := 0.0;
// Stop at position isn't needed, but expose the params here and guess at logical defaults in case they are needed in the future.
ax.MoveParameters.StopParams.StopAtPosition.Activate := FALSE;
ax.MoveParameters.StopParams.StopAtPosition.Deceleration := ax.MoveParameters.Deceleration;
ax.MoveParameters.StopParams.StopAtPosition.Position := ax.MoveParameters.Position;

// Call motion command to get status, and issue the stop and possibly enable commands.
ActionCallMotionFunctions;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_ERROR_STOP;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Shut off the stop command
ax.Commands.StopReq:= FALSE;
END_ACTION
TRANSITION Stop Cmd is done or in error FROM Step_Error_Stop TO Step_Error_DrvRstWait:=
(* @LANGUAGE := 'st' *)
// Stop command done or an error, or axis was disabled due to error
ax.Status.PlcOpenState = mcAXIS_STANDSTILL OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_DISABLED

END_TRANSITION
(* @SFCNOJUMP := 'Step_Error_DrvRstWait' *)
STEP Step_Error_DrvRstWait:
(* @LANGUAGE := 'st' *)
// Drive is stopped and is (was) in error.
// The axis may or may not be enabled (powered) depending on the error,
// but if it is enabled, don't presume we want it disabled.
// We wait here for a drive reset request or a disable request.
// Preserve the drive reset and disable requests, but clear the others
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_DISABLE_MASK + MACM_DRIVE_RESET_MASK, _IO_Commands := ax.Commands);

// Call motion command to get status, and disable the drive.
ActionCallMotionFunctions;

// Run a timer to force the step to be active for a minimum time
tmrDriveReset(IN:= TRUE, PT:= T#500ms);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_ERROR_DRVRSTWAIT;

// Reset the wait timer
tmrDriveReset(IN:= FALSE);
END_ACTION
TRANSITION drive reset req FROM Step_Error_DrvRstWait TO Step_Error_DriveReset:=
(* @LANGUAGE := 'st' *)
// Drive reset req received and hold time is satisfied
ax.Commands.DriveResetReq AND
tmrDriveReset.Q
END_TRANSITION
(* @SFCNOJUMP := 'Step_Error_DriveReset' *)
TRANSITION Drive disable req FROM Step_Error_DrvRstWait TO Step_Error_Disable:=
(* @LANGUAGE := 'st' *)
// Drive disable req and hold time is satisfied
ax.Commands.DisableReq AND
tmrDriveReset.Q
END_TRANSITION
(* @SFCNOJUMP := 'Step_Error_Disable' *)
STEP Step_Error_Disable:
(* @LANGUAGE := 'st' *)
// Clear the enable command, and the drive will be disabled.

// Clear all the commands, but specifically the Enable Cmd to power off the axis.
// Clear all the requests.
fctClearMotionCommands(_I_CmdMask := MACM_NOMASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_NOMASK, _IO_Commands := ax.Commands);

// Call motion command to get status, and issue the (false) enable cmd
ActionCallMotionFunctions;

// Run a timer to force the step to be active for a minimum time
tmrDriveReset(IN:= TRUE, PT:= T#500ms);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_ERROR_DISABLE;

// Reset the wait timer
tmrDriveReset(IN:= FALSE);
END_ACTION
TRANSITION hold time done FROM Step_Error_Disable TO Step_Error_DrvRstWait:=
(* @LANGUAGE := 'st' *)
// Hold time is satisfied. Ignore states as we don't want to get stuck here.
tmrDriveReset.Q
END_TRANSITION
(* @SFCISJUMP := 'Step_Error_DrvRstWait' *)
STEP Step_Error_DriveReset:
(* @LANGUAGE := 'st' *)
// Exert the drive reset cmd
// The axis may or may not be enabled (powered) depending on the error,
// but if it is enabled, don't presume we want it disabled, so honor the enable cmd if present.
// Clear the requests
ax.Commands.DriveResetCmd := TRUE;
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_DRIVE_RESET_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_NOMASK, _IO_Commands := ax.Commands);

// Call motion command to get status, and issue the drive reset command
ActionCallMotionFunctions;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_ERROR_DRVRST;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Clear the command
ax.Commands.DriveResetCmd := FALSE;
END_ACTION
TRANSITION Invalid Status FROM Step_Error_DriveReset TO Step_AxisValid_Check:=
(* @LANGUAGE := 'st' *)
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_ACTIVATION OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_NULL OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_INVALID OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CHANGED OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CORRUPT OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_IN_USE OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PAR_NULL

END_TRANSITION
(* @SFCISJUMP := 'Step_AxisValid_Check' *)
TRANSITION error FROM Step_Error_DriveReset TO Step_Error_DrvRstWait:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_DrvRstWait' *)
TRANSITION valid, no errors, drive in error stop FROM Step_Error_DriveReset TO Step_Error_DrvRstWait:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), and no errors,
// but drive is in ErrorStop. It shouldn't be, but if it is
// the reset didn't work. Go back to DriveResetWait
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP


END_TRANSITION
(* @SFCISJUMP := 'Step_Error_DrvRstWait' *)
TRANSITION valid, no errors, drive (powered) in standstill FROM Step_Error_DriveReset TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), and no errors,
// and drive in enabled and in standstill
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Status.PlcOpenState = mcAXIS_STANDSTILL


END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid, no errors, drive disabled FROM Step_Error_DriveReset TO Step_Disabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), and no errors,
// and drive in disabled
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Status.PlcOpenState = mcAXIS_DISABLED


END_TRANSITION
(* @SFCISJUMP := 'Step_Disabled' *)
TRANSITION Mode problem FROM Step_Enabled TO Step_Disabled:=
(* @LANGUAGE := 'st' *)
// mode mismatch timer times out
tmrModeMismatch.Q
END_TRANSITION
(* @SFCISJUMP := 'Step_Disabled' *)
TRANSITION valid axis, engage as a slave FROM Step_Enabled TO Step_EngageReq:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and engaged as a slave
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Status.PlcOpenState = mcAXIS_SYNCHRONIZED_MOTION
END_TRANSITION
(* @SFCNOJUMP := 'Step_EngageReq' *)
STEP Step_EngageReq:
(* @LANGUAGE := 'st' *)
// An engage request was made. From here you can:
// Engage as a slave or due to move permissives or some other request,
// disengage, react to errors or get to the disengaged state.
// TODO: Figure out if any reaction to MoveNotAllowed or a bad Engage as Slave permissive is needed.
// Other moves (jog, abs, rel) are not allowed.
// Note the halt request is not acted on while synchronized to the master, as this axis will follow the axis, and presumalbly the master will stop if it needs to.
// The halt request, however, is allowed to stand, so if set, the axis will stop after being disengaged.
// Note that the disable, halt, and stop requests are allowed to stand, but it will be handled by transitioning to disengaged and then onto ready, and then stopped.
// NOTE: It is probably the case for coordinated moves that the slave be engaged as a move permissive for the master, so the above requests should probably stop the master.

// Check positive and negative move permissives and allowable position range
ActionChkPermissiveEngagedSlave;

// If a move is allowed, allow the axis to be engaged as a slave, otherwise don't
IF NOT ax.Commands.MoveNotAllowed THEN
  // Move allowed, so engaging is allowed - set the command
  // TODO: Anything to do? Action is on the master side, so slave may not need to do anything
  ;
ELSE
  // Move not allowed.
  // TODO: Anything to do? Action is on the master side, so slave may not need to do anything
  ;
END_IF;

// If the parameter is set, then set the halt request. Halt won't have an effect while
//engaged, but the axis will be halted after disengaging.
ax.Commands.HaltReq:= ax.MoveParameters.HaltOnSlaveDisengage;

ax.Commands.EnableCmd := TRUE; // Keep from turning off the axis.
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK, _IO_Commands := ax.Commands);
reqMask := MACM_DISABLE_MASK + MACM_HALT_MASK + MACM_STOP_MASK;
fctClearMotionRequests(_I_ReqMask := reqMask, _IO_Commands := ax.Commands);

// Call motion command to get status, and issue the enable, and hopefully the engage slave cmd.
ActionCallMotionFunctions;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_ENGAGED_AS_SLAVE;
END_ACTION
TRANSITION FROM Step_EngageReq TO Step_Ignore_Axis:=
ax.Ignore
END_TRANSITION
(* @SFCISJUMP := 'Step_Ignore_Axis' *)
TRANSITION Invalid status FROM Step_EngageReq TO Step_Disengage:=
(* @LANGUAGE := 'st' *)
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_ACTIVATION OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_NULL OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_INVALID OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CHANGED OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_CORRUPT OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_MPLINK_IN_USE OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PAR_NULL

END_TRANSITION
(* @SFCNOJUMP := 'Step_Disengage' *)
TRANSITION global or axis stop req FROM Step_EngageReq TO Step_Disengage:=
(* @LANGUAGE := 'st' *)
// Global or axis Stop Request
// Note these may be attempted even if there is an error
// as errors are not checked before this.
ax.Commands.StopReq OR gMotionCommands.StopReq

END_TRANSITION
(* @SFCNOJUMP := 'Step_Disengage' *)
TRANSITION valid and global or axis disable req FROM Step_EngageReq TO Step_Disengage:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and global or axis disable req
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
(ax.Commands.DisableReq OR gMotionCommands.DisableReq)
END_TRANSITION
(* @SFCNOJUMP := 'Step_Disengage' *)
TRANSITION Disengaged as slave FROM Step_EngageReq TO Step_Disengage:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors, but not in sync motion any more
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Status.PlcOpenState <> mcAXIS_SYNCHRONIZED_MOTION
END_TRANSITION
(* @SFCNOJUMP := 'Step_Disengage' *)
TRANSITION valid but error FROM Step_EngageReq TO Step_Disengage:=
(* @LANGUAGE := 'st' *)
// Axis is valid, but there are errors
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION
END_TRANSITION
(* @SFCNOJUMP := 'Step_Disengage' *)
STEP Step_Disengage:
(* @LANGUAGE := 'st' *)
// The axis was engaged as a slave but is now disengaged,
// either because of a request or error.
// Excert the enable command and the disengage command.
// Allow the disable, halt, and stop requests to stand

// TODO: Deal with MpAxisCoupling
// TODO: Deal with whether or not motion should stop or continue.
// NOTE: It is probably the case for coordinated moves that the slave be engaged as a move permissive for the master, so the above requests should probably stop the master.

ax.Commands.EnableCmd := TRUE;
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_DISABLE_MASK + MACM_HALT_MASK + MACM_STOP_MASK, _IO_Commands := ax.Commands);

// Call motion command to get status, and issue the enable and disengage commands.
// TODO: Implement Axis Coupling
ActionCallMotionFunctions;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_DISENGAGE_AS_SLAVE;
END_ACTION
TRANSITION FROM Step_Disengage TO Step_Enabled:=
TRUE
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid, home req FROM Step_Enabled TO Step_HomeReq:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and home req
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Commands.HomeReq
END_TRANSITION
(* @SFCNOJUMP := 'Step_HomeReq' *)
STEP Step_HomeReq:
(* @LANGUAGE := 'st' *)
// From here, try to home the axis. It will either have an error or become homed.
// Preserve the enable bit so the axis isn't forced off.
// Turn off the other requests.
ax.Commands.HomeCmd := TRUE;
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_HOME_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_NOMASK, _IO_Commands := ax.Commands);

// Call motion command to get status, and issue the home command, and possibly the enable command.
ActionCallMotionFunctions;

// Run the timer which holds here for a bit
tmrHomeMinimum(IN:= TRUE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_HOME_REQ;
// reset the timer
tmrHomeMinimum(IN:= FALSE, PT:= T#100ms);
END_ACTION
TRANSITION error FROM Step_HomeReq TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION homing FROM Step_HomeReq TO StepHoming:=
(* @LANGUAGE := 'st' *)
// Timer check ensures homing command was at least received.
tmrHomeMinimum.Q AND
(ax.Status.AxisDiagnostics.ExecutingCommand = mcAXIS_CMD_HOMING OR
ax.Status.PlcOpenState = mcAXIS_HOMING OR
ax.Status.PlcOpenState = mcAXIS_DISABLED OR
ax.Status.PlcOpenState = mcAXIS_STANDSTILL OR
ax.Status.PlcOpenState = mcAXIS_STOPPING)
END_TRANSITION
(* @SFCNOJUMP := 'StepHoming' *)
STEP StepHoming:
(* @LANGUAGE := 'st' *)
// Continue the home command
// Preserve the enable bit so the axis isn't forced off.
// Turn off the other requests.
ax.Commands.HomeCmd := TRUE;
fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_HOME_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := MACM_NOMASK, _IO_Commands := ax.Commands);

// Call motion command to get status, and issue the home command, and possibly the enable command.
ActionCallMotionFunctions;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_HOMING;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Make sure command is off on exit
ax.Commands.HomeCmd:= FALSE;
END_ACTION
TRANSITION error FROM StepHoming TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION Homed FROM StepHoming TO Step_Homed:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), homed, and no errors and disabled or standstill
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Status.IsHomed AND
(ax.Status.PlcOpenState = mcAXIS_DISABLED OR
ax.Status.PlcOpenState = mcAXIS_STANDSTILL)
END_TRANSITION
(* @SFCNOJUMP := 'Step_Homed' *)
STEP Step_Homed:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_HOMED;
// Clear the force set ref
ax.ForceSetRef := FALSE;

END_ACTION
TRANSITION Drive disabled FROM Step_Homed TO Step_Disabled:=
(* @LANGUAGE := 'st' *)
// Drive is disabled after homing, so go tho that state
ax.Status.PlcOpenState = mcAXIS_DISABLED
END_TRANSITION
(* @SFCISJUMP := 'Step_Disabled' *)
TRANSITION Drive enabled FROM Step_Homed TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// Drive is enabled after homing, so go to that state
ax.Status.PlcOpenState = mcAXIS_STANDSTILL
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid, jog req FROM Step_Enabled TO Step_JogReq:=
(* @LANGUAGE := 'st' *)
// Velocity move or jog positive limit or jog negative limit used in place of jog
FALSE
// Valid status (allow the couple axis warnings), no errors and jog req
// (ax.statusFpMpAxisBasic.AxisError = mcAXIS_NO_ERROR OR
// ax.statusFpMpAxisBasic.AxisError = mcAXIS_WRN_PLC_OPEN OR
// ax.statusFpMpAxisBasic.AxisError = mcAXIS_WRN_MULTIPLE_COMMAND) AND
// NOT ax.statusFpMpAxisBasic.Error AND
// ax.Commands.MoveJogReq
END_TRANSITION
(* @SFCNOJUMP := 'Step_JogReq' *)
STEP Step_JogReq:
(* @LANGUAGE := 'st' *)
// If the move is allowed, execute the jog command, and keep the enable command or the axis will shut off.
// Preserve the other move commands.  Other move requests will cause a state change.
// Preserve the halt, stop, and disable requests.
ax.Commands.EnableCmd := TRUE;

// Use the move parameter position limits, accel, decel and jerk for the jog
// This way, the application can worry about these values in the 
// parameter structure, but not have to worry about the jog limits.
ax.MoveParameters.JogParams.Velocity := ax.MoveParameters.Velocity;
ax.MoveParameters.JogParams.LimitPosition.FirstPosition :=  axPositionLimits.PositionLimitNeg;
ax.MoveParameters.JogParams.LimitPosition.LastPosition :=  axPositionLimits.PositionLimitPos;
ax.MoveParameters.JogParams.Acceleration := ax.MoveParameters.Acceleration;
ax.MoveParameters.JogParams.Deceleration := ax.MoveParameters.Deceleration;
ax.MoveParameters.JogParams.Jerk := ax.MoveParameters.MaxJerk;

// Set the request mask for those requests we know we want to honor.
// This move may or may not be allowed, but since it is a jog, it the request should be maintained,
// and a stop/halt/move/ or other reqeest will clear it.
reqMask := MACM_DISABLE_MASK + MACM_JOG_POSITIVE_MASK + MACM_JOG_NEGATIVE_MASK +
MACM_VELOCITY_MOVE_MASK + MACM_RELATIVE_MOVE_MASK + MACM_ABSOLUTE_MOVE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;

// Check move permissives -- move of undefined length
ActionChkPermissiveContinuous;

// If the move is allowed, set the command, otherwise clear it
IF NOT ax.Commands.MoveNotAllowed THEN
  // Move is allowed.
  // Set the command but don't clear the request -- the jog should continue
  // as long as the request is held
  ax.Commands.MoveJogCmd:= TRUE;
  reqMask := reqMask + MACM_JOG_MASK;
ELSE
  // Move not allowed. Clear the cmd, req, and issue a halt
  ax.Commands.MoveJogReq:= FALSE;
  ax.Commands.MoveJogCmd:= FALSE;
  ax.Commands.HaltReq:= TRUE;
END_IF;

fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_JOG_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := reqMask, _IO_Commands := ax.Commands);

// Call the motion commands
ActionCallMotionFunctions;

// Run the mode mismatch timer if the mode is not ok.
// Assume mode is okay - no modes on this system
tmrModeMismatch(IN:= FALSE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_JOG;

// Reset the mode check timer
tmrModeMismatch(IN:= FALSE);


END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Shut off the command and request.
// Unlike other commands, the request for a jog stays on as long as the move is desired.
ax.Commands.MoveJogReq:= FALSE;
ax.Commands.MoveJogCmd:= FALSE;

// Call the motion commands
// Do this here, so the motion function blocks are guaranteed to see a
// falling edge of the command. Unexpected, but not necessarily incorrect
// behavior may result when one command is not ended before another starts.
ActionCallMotionFunctions;

END_ACTION
TRANSITION error FROM Step_JogReq TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION stop req FROM Step_JogReq TO Step_StopReq:=
(* @LANGUAGE := 'st' *)
// A global or local stop is requested 
ax.Commands.StopReq OR gMotionCommands.StopReq
END_TRANSITION
(* @SFCISJUMP := 'Step_StopReq' *)
TRANSITION mode problem or halt req FROM Step_JogReq TO Step_HaltReq:=
(* @LANGUAGE := 'st' *)
// Mode problem or axis or global halt request
tmrModeMismatch.Q OR
ax.Commands.HaltReq OR gMotionCommands.HaltReq
END_TRANSITION
(* @SFCISJUMP := 'Step_HaltReq' *)
TRANSITION no jog req or other move req FROM Step_JogReq TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and jog req goes away
// or another move request comes in. Note stop and halt are handled separately.
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
(NOT ax.Commands.MoveJogReq OR
ax.Commands.DisableReq OR
ax.Commands.MoveJogPositiveReq OR
ax.Commands.MoveJogNegativeReq OR
ax.Commands.MoveVelocityReq OR
ax.Commands.MoveRelativeReq OR
ax.Commands.MoveAbsoluteReq)
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid, jog pos limit req FROM Step_Enabled TO Step_JogPosLimitReq:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and jog positive req
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Commands.MoveJogPositiveReq
END_TRANSITION
(* @SFCNOJUMP := 'Step_JogPosLimitReq' *)
STEP Step_JogPosLimitReq:
(* @LANGUAGE := 'st' *)
// If the move is allowed, execute the jog positive limit command, and keep the enable command or the axis will shut off.
// Preserve the other move commands.  Other move requests will cause a state change.
// Preserve the halt, stop, and disable requests.
ax.Commands.EnableCmd := TRUE;

// Use the move parameter position limits, accel, decel and jerk for the jog
// This way, the application can worry about these values in the 
// parameter structure, but not have to worry about the jog limits.
ax.MoveParameters.JogParams.Velocity := ax.MoveParameters.Velocity;
ax.MoveParameters.JogParams.LimitPosition.FirstPosition :=  axPositionLimits.PositionLimitNeg;
ax.MoveParameters.JogParams.LimitPosition.LastPosition :=  axPositionLimits.PositionLimitPos;
ax.MoveParameters.JogParams.Acceleration := ax.MoveParameters.Acceleration;
ax.MoveParameters.JogParams.Deceleration := ax.MoveParameters.Deceleration;
ax.MoveParameters.JogParams.Jerk := ax.MoveParameters.MaxJerk;

// Set the request mask for those requests we know we want to honor.
// This move may or may not be allowed, but since it is a jog, it the request should be maintained,
// and a stop/halt/move/ or other reqeest will clear it.
reqMask := MACM_DISABLE_MASK + MACM_JOG_MASK + MACM_JOG_NEGATIVE_MASK +
MACM_VELOCITY_MOVE_MASK + MACM_RELATIVE_MOVE_MASK + MACM_ABSOLUTE_MOVE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;

// Check move permissives -- move of undefined length
ActionChkPermissiveContinuous;

// If the move is allowed, set the command, otherwise clear it
IF NOT ax.Commands.MoveNotAllowed THEN
  // Move is allowed.
  // Set the command but don't clear the request -- the jog should continue
  // as long as the request is held
  ax.Commands.MoveJogPositiveCmd:= TRUE;
  reqMask := reqMask + MACM_JOG_POSITIVE_MASK;
ELSE
  // Move not allowed. Clear the cmd, req, and issue a halt
  ax.Commands.MoveJogPositiveReq:= FALSE;
  ax.Commands.MoveJogPositiveCmd:= FALSE;
  ax.Commands.HaltReq:= TRUE;
END_IF;

fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_JOG_POSITIVE_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := reqMask, _IO_Commands := ax.Commands);

// Call the motion commands
ActionCallMotionFunctions;

// Run the mode mismatch timer if the mode is not ok.
// Assume mode is okay - no modes on this system
tmrModeMismatch(IN:= FALSE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_JOGPOSLIMIT;

// Reset the mode check timer
tmrModeMismatch(IN:= FALSE);

END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Shut off the command and request.
// Unlike other commands, the request for a jog stays on as long as the move is desired.
ax.Commands.MoveJogPositiveCmd:= FALSE;
ax.Commands.MoveJogPositiveReq:= FALSE;

// Call the motion commands
// Do this here, so the motion function blocks are guaranteed to see a
// falling edge of the command. Unexpected, but not necessarily incorrect
// behavior may result when one command is not ended before another starts.
ActionCallMotionFunctions;

END_ACTION
TRANSITION error FROM Step_JogPosLimitReq TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION stop req FROM Step_JogPosLimitReq TO Step_StopReq:=
(* @LANGUAGE := 'st' *)
// A global or local stop is requested 
ax.Commands.StopReq OR gMotionCommands.StopReq
END_TRANSITION
(* @SFCISJUMP := 'Step_StopReq' *)
TRANSITION mode problem or halt req FROM Step_JogPosLimitReq TO Step_HaltReq:=
(* @LANGUAGE := 'st' *)
// Mode problem or axis or global halt request
tmrModeMismatch.Q OR
ax.Commands.HaltReq OR gMotionCommands.HaltReq
END_TRANSITION
(* @SFCISJUMP := 'Step_HaltReq' *)
TRANSITION No jog pos limit req or othe rmove req FROM Step_JogPosLimitReq TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and jog req goes away
// or another move request comes in. Note stop and halt are handled separately.
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
(NOT ax.Commands.MoveJogPositiveReq OR
ax.Commands.DisableReq OR
ax.Commands.MoveJogReq OR
ax.Commands.MoveJogNegativeReq OR
ax.Commands.MoveVelocityReq OR
ax.Commands.MoveRelativeReq OR
ax.Commands.MoveAbsoluteReq)
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid, jog neg limit req FROM Step_Enabled TO Step_JogNegLimitReq:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and jog negative req
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Commands.MoveJogNegativeReq
END_TRANSITION
(* @SFCNOJUMP := 'Step_JogNegLimitReq' *)
STEP Step_JogNegLimitReq:
(* @LANGUAGE := 'st' *)
// If the move is allowed, execute the jog negative limit command, and keep the enable command or the axis will shut off.
// Preserve the other move commands.  Other move requests will cause a state change.
// Preserve the halt, stop, and disable requests.
ax.Commands.EnableCmd := TRUE;

// Use the move parameter position limits, accel, decel and jerk for the jog
// This way, the application can worry about these values in the 
// parameter structure, but not have to worry about the jog limits.
ax.MoveParameters.JogParams.Velocity := ax.MoveParameters.Velocity;
ax.MoveParameters.JogParams.LimitPosition.FirstPosition :=  axPositionLimits.PositionLimitNeg;
ax.MoveParameters.JogParams.LimitPosition.LastPosition :=  axPositionLimits.PositionLimitPos;
ax.MoveParameters.JogParams.Acceleration := ax.MoveParameters.Acceleration;
ax.MoveParameters.JogParams.Deceleration := ax.MoveParameters.Deceleration;
ax.MoveParameters.JogParams.Jerk := ax.MoveParameters.MaxJerk;

// Set the request mask for those requests we know we want to honor.
// This move may or may not be allowed, but since it is a jog, it the request should be maintained,
// and a stop/halt/move/ or other reqeest will clear it.
reqMask := MACM_DISABLE_MASK + MACM_JOG_MASK + MACM_JOG_POSITIVE_MASK + 
MACM_VELOCITY_MOVE_MASK + MACM_RELATIVE_MOVE_MASK + MACM_ABSOLUTE_MOVE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;

// Check move permissives -- move of undefined length
ActionChkPermissiveContinuous;

// If the move is allowed, set the command, otherwise clear it
IF NOT ax.Commands.MoveNotAllowed THEN
  // Move is allowed.
  // Set the command but don't clear the request -- the jog should continue
  // as long as the request is held
  ax.Commands.MoveJogNegativeCmd:= TRUE;
  reqMask := reqMask + MACM_JOG_NEGATIVE_MASK;
ELSE
  // Move not allowed. Clear the cmd, req, and issue a halt
  ax.Commands.MoveJogNegativeReq:= FALSE;
  ax.Commands.MoveJogNegativeCmd:= FALSE;
  ax.Commands.HaltReq:= TRUE;
END_IF;

fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_JOG_NEGATIVE_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := reqMask, _IO_Commands := ax.Commands);

// Call the motion commands
ActionCallMotionFunctions;

// Run the mode mismatch timer if the mode is not ok.
// Assume mode is okay - no modes on this system
tmrModeMismatch(IN:= FALSE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_JOGNEGLIMIT;

// Reset the mode check timer
tmrModeMismatch(IN:= FALSE);

END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Shut off the command and request.
// Unlike other commands, the request for a jog stays on as long as the move is desired.
ax.Commands.MoveJogNegativeCmd:= FALSE;
ax.Commands.MoveJogNegativeReq:= FALSE;

// Call the motion commands
// Do this here, so the motion function blocks are guaranteed to see a
// falling edge of the command. Unexpected, but not necessarily incorrect
// behavior may result when one command is not ended before another starts.
ActionCallMotionFunctions;

END_ACTION
TRANSITION error FROM Step_JogNegLimitReq TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION stop req FROM Step_JogNegLimitReq TO Step_StopReq:=
(* @LANGUAGE := 'st' *)
// A global or local stop is requested 
ax.Commands.StopReq OR gMotionCommands.StopReq
END_TRANSITION
(* @SFCISJUMP := 'Step_StopReq' *)
TRANSITION mode problem or halt req FROM Step_JogNegLimitReq TO Step_HaltReq:=
(* @LANGUAGE := 'st' *)
// Mode problem or axis or global halt request
tmrModeMismatch.Q OR
ax.Commands.HaltReq OR gMotionCommands.HaltReq
END_TRANSITION
(* @SFCISJUMP := 'Step_HaltReq' *)
TRANSITION No jog neg limit req or othe rmove req FROM Step_JogNegLimitReq TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and jog req goes away
// or another move request comes in. Note stop and halt are handled separately.
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
(NOT ax.Commands.MoveJogNegativeReq OR
ax.Commands.DisableReq OR
ax.Commands.MoveJogReq OR
ax.Commands.MoveJogPositiveReq OR
ax.Commands.MoveVelocityReq OR
ax.Commands.MoveRelativeReq OR
ax.Commands.MoveAbsoluteReq)
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid, move velocity FROM Step_Enabled TO Step_MoveVelocityReq:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and jog negative req
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Commands.MoveVelocityReq
END_TRANSITION
(* @SFCNOJUMP := 'Step_MoveVelocityReq' *)
STEP Step_MoveVelocityReq:
(* @LANGUAGE := 'st' *)
// If the move is allowed, execute the move velocity command, and keep the enable command or the axis will shut off.
// Preserve the other move commands.  Other move requests will cause a state change.
// Preserve the halt, stop, and disable requests.
ax.Commands.EnableCmd := TRUE;

// Set the request mask for those requests we know we want to honor.
// This move may or may not be allowed, but since it is a jog, it the request should be maintained,
// and a stop/halt/move/ or other reqeest will clear it.
reqMask := MACM_DISABLE_MASK + MACM_JOG_MASK + MACM_JOG_POSITIVE_MASK + MACM_JOG_NEGATIVE_MASK +
MACM_RELATIVE_MOVE_MASK + MACM_ABSOLUTE_MOVE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;

// Check move permissives -- move of undefined length
ActionChkPermissiveContinuous;

// If the move is allowed, set the command, otherwise clear it
IF NOT ax.Commands.MoveNotAllowed THEN
  // Move is allowed.
  // Set the command but don't clear the request -- the velocity move should continue
  // as long as the request is held
  ax.Commands.MoveVelocityCmd:= TRUE;
  reqMask := reqMask + MACM_VELOCITY_MOVE_MASK;
ELSE
  // Move not allowed. Clear the cmd, req, and issue a halt
  ax.Commands.MoveVelocityReq:= FALSE;
  ax.Commands.MoveVelocityCmd:= FALSE;
  ax.Commands.HaltReq:= TRUE;
END_IF;

fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_VELOCITY_MOVE_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := reqMask, _IO_Commands := ax.Commands);

// Call the motion commands
ActionCallMotionFunctions;

// Run the mode mismatch timer if the mode is not ok.
// Assume mode is okay - no modes on this system
tmrModeMismatch(IN:= FALSE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_MOVE_VELOCITY;

// Reset the mode check timer
tmrModeMismatch(IN:= FALSE);

END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Shut off the command and request.
// Unlike other commands, the request for a velocity move stays on as long as the move is desired.
ax.Commands.MoveVelocityCmd:= FALSE;
ax.Commands.MoveVelocityReq:= FALSE;

// Call the motion commands
// Do this here, so the motion function blocks are guaranteed to see a
// falling edge of the command. Unexpected, but not necessarily incorrect
// behavior may result when one command is not ended before another starts.
ActionCallMotionFunctions;

END_ACTION
TRANSITION error FROM Step_MoveVelocityReq TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION stop req FROM Step_MoveVelocityReq TO Step_StopReq:=
(* @LANGUAGE := 'st' *)
// A global or local stop is requested 
ax.Commands.StopReq OR gMotionCommands.StopReq
END_TRANSITION
(* @SFCISJUMP := 'Step_StopReq' *)
TRANSITION mode problem or halt req FROM Step_MoveVelocityReq TO Step_HaltReq:=
(* @LANGUAGE := 'st' *)
// Mode problem or axis or global halt request
tmrModeMismatch.Q OR
ax.Commands.HaltReq OR gMotionCommands.HaltReq
END_TRANSITION
(* @SFCISJUMP := 'Step_HaltReq' *)
TRANSITION no vel req or other move req FROM Step_MoveVelocityReq TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and vel req goes away
// or another move request comes in. Note stop and halt are handled separately.
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
(NOT ax.Commands.MoveVelocityReq OR
ax.Commands.DisableReq OR
ax.Commands.MoveJogReq OR
ax.Commands.MoveJogPositiveReq OR
ax.Commands.MoveJogNegativeReq OR
ax.Commands.MoveRelativeReq OR
ax.Commands.MoveAbsoluteReq)
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid, move rel req FROM Step_Enabled TO Step_MoveRelativeReq:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and jog negative req
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Commands.MoveRelativeReq
END_TRANSITION
(* @SFCNOJUMP := 'Step_MoveRelativeReq' *)
STEP Step_MoveRelativeReq:
(* @LANGUAGE := 'st' *)
// If the move is allowed, execute the move relative command, and keep the enable command or the axis will shut off.
// Preserve the other move commands.  Other move requests will cause a state change.
// Preserve the halt, stop, and disable requests.
ax.Commands.EnableCmd := TRUE;

// Set the request mask for those requests we know we want to honor.
// This move may or may not be allowed, but the request has already been honored, so it can be cleared.
reqMask := MACM_DISABLE_MASK + MACM_JOG_MASK + MACM_JOG_POSITIVE_MASK + MACM_JOG_NEGATIVE_MASK +
MACM_VELOCITY_MOVE_MASK + MACM_ABSOLUTE_MOVE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;

// Check move permissives
ActionChkPermissiveRel;

// If the move is allowed, set the command, otherwise clear it
IF NOT ax.Commands.MoveNotAllowed THEN
  // Move is allowed.
  // Set the command but don't clear the request -- the jog should continue
  // as long as the request is held
  ax.Commands.MoveRelativeCmd:= TRUE;
ELSE
  // Move not allowed. Clear the cmd issue a halt
  ax.Commands.MoveRelativeCmd:= FALSE;
  ax.Commands.HaltReq:= TRUE;
END_IF;

fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_RELATIVE_MOVE_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := reqMask, _IO_Commands := ax.Commands);

// Call the motion commands
ActionCallMotionFunctions;

// Run the mode mismatch timer if the mode is not ok.
// Assume mode is okay - no modes on this system
tmrModeMismatch(IN:= FALSE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_MOVE_RELATIVE;

// Reset the mode check timer
tmrModeMismatch(IN:= FALSE);

// Take a snapshot of the current position.
// This is to allow permissive checking while on the move
// while supporting a changealbe move window
ax.MoveParameters.PermissiveCheck.StartPosition := ax.Status.Position;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Shut off the command and request.
ax.Commands.MoveRelativeCmd:= FALSE;
ax.Commands.MoveRelativeReq:= FALSE;

// Call the motion commands
// Do this here, so the motion function blocks are guaranteed to see a
// falling edge of the command. Unexpected, but not necessarily incorrect
// behavior may result when one command is not ended before another starts.
ActionCallMotionFunctions;

END_ACTION
TRANSITION error FROM Step_MoveRelativeReq TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION stop req FROM Step_MoveRelativeReq TO Step_StopReq:=
(* @LANGUAGE := 'st' *)
// A global or local stop is requested 
ax.Commands.StopReq OR gMotionCommands.StopReq
END_TRANSITION
(* @SFCISJUMP := 'Step_StopReq' *)
TRANSITION mode problem or halt req FROM Step_MoveRelativeReq TO Step_HaltReq:=
(* @LANGUAGE := 'st' *)
// Mode problem or axis or global halt request
tmrModeMismatch.Q OR
ax.Commands.HaltReq OR gMotionCommands.HaltReq
END_TRANSITION
(* @SFCISJUMP := 'Step_HaltReq' *)
TRANSITION move done or other move req FROM Step_MoveRelativeReq TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and move is done
// or another move request comes in. Note stop and halt are handled separately.
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
(ax.Status.IsMoveDone AND ax.Status.PlcOpenState = mcAXIS_STANDSTILL) OR
(ax.Commands.DisableReq OR
ax.Commands.MoveJogReq OR
ax.Commands.MoveJogPositiveReq OR
ax.Commands.MoveJogNegativeReq OR
ax.Commands.MoveVelocityReq OR
ax.Commands.MoveAbsoluteReq)
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid, abs move req FROM Step_Enabled TO Step_MoveAbsoluteReq:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and jog negative req
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
NOT ax.statusFpMpAxisBasic.Error AND
ax.Commands.MoveAbsoluteReq
END_TRANSITION
(* @SFCNOJUMP := 'Step_MoveAbsoluteReq' *)
STEP Step_MoveAbsoluteReq:
(* @LANGUAGE := 'st' *)
// If the move is allowed, execute the move absolute command, and keep the enable command or the axis will shut off.
// Preserve the other move commands.  Other move requests will cause a state change.
// Preserve the halt, stop, and disable requests.
ax.Commands.EnableCmd := TRUE;

// Set the request mask for those requests we know we want to honor.
// This move may or may not be allowed, but the request has already been honored, so it can be cleared.
reqMask := MACM_DISABLE_MASK + MACM_JOG_MASK + MACM_JOG_POSITIVE_MASK + MACM_JOG_NEGATIVE_MASK +
MACM_VELOCITY_MOVE_MASK + MACM_RELATIVE_MOVE_MASK + MACM_STOP_MASK + MACM_HALT_MASK;

// Check move permissives
ActionChkPermissiveAbs;

// If the move is allowed, set the command, otherwise clear it
IF NOT ax.Commands.MoveNotAllowed THEN
  // Move is allowed.
  // Set the command but don't clear the request -- the jog should continue
  // as long as the request is held
  ax.Commands.MoveAbsoluteCmd:= TRUE;
ELSE
  // Move not allowed. Clear the cmd issue a halt
  ax.Commands.MoveAbsoluteCmd:= FALSE;
  ax.Commands.HaltReq:= TRUE;
END_IF;

fctClearMotionCommands(_I_CmdMask := MACM_ENABLE_MASK + MACM_ABSOLUTE_MOVE_MASK, _IO_Commands := ax.Commands);
fctClearMotionRequests(_I_ReqMask := reqMask, _IO_Commands := ax.Commands);

// Call the motion commands
ActionCallMotionFunctions;

// Run the mode mismatch timer if the mode is not ok.
// Assume mode is okay - no modes on this system
tmrModeMismatch(IN:= FALSE);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
// Set the state
ax.SMState:= GAMOT_ASMS_MOVE_ABSOLUTE;

// Reset the mode check timer
tmrModeMismatch(IN:= FALSE);
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
// Shut off the command and request.
ax.Commands.MoveAbsoluteCmd:= FALSE;
ax.Commands.MoveAbsoluteReq:= FALSE;

// Call the motion commands
// Do this here, so the motion function blocks are guaranteed to see a
// falling edge of the command. Unexpected, but not necessarily incorrect
// behavior may result when one command is not ended before another starts.
ActionCallMotionFunctions;

END_ACTION
TRANSITION error FROM Step_MoveAbsoluteReq TO Step_Error_Stop:=
(* @LANGUAGE := 'st' *)
// Valid status, but an error
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_Stop' *)
TRANSITION stop req FROM Step_MoveAbsoluteReq TO Step_StopReq:=
(* @LANGUAGE := 'st' *)
// A global or local stop is requested 
ax.Commands.StopReq OR gMotionCommands.StopReq
END_TRANSITION
(* @SFCISJUMP := 'Step_StopReq' *)
TRANSITION mode problem or halt req FROM Step_MoveAbsoluteReq TO Step_HaltReq:=
(* @LANGUAGE := 'st' *)
// Mode problem or axis or global halt request
tmrModeMismatch.Q OR
ax.Commands.HaltReq OR gMotionCommands.HaltReq
END_TRANSITION
(* @SFCISJUMP := 'Step_HaltReq' *)
TRANSITION move done or other move req FROM Step_MoveAbsoluteReq TO Step_Enabled:=
(* @LANGUAGE := 'st' *)
// Valid status (allow the couple axis warnings), no errors and move is done
// or another move request comes in. Note stop and halt are handled separately.
(ax.statusFpMpAxisBasic.StatusId = mcAXIS_NO_ERROR OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_PLC_OPEN OR
ax.statusFpMpAxisBasic.StatusId = mcAXIS_WRN_MULTIPLE_COMMAND) AND
(ax.Status.IsMoveDone AND ax.Status.PlcOpenState = mcAXIS_STANDSTILL) OR
(ax.Commands.DisableReq OR
ax.Commands.MoveJogReq OR
ax.Commands.MoveJogPositiveReq OR
ax.Commands.MoveJogNegativeReq OR
ax.Commands.MoveVelocityReq OR
ax.Commands.MoveRelativeReq)
END_TRANSITION
(* @SFCISJUMP := 'Step_Enabled' *)
TRANSITION valid but error FROM Step_AxisValid_Check TO Step_Error_DrvRstWait:=
(* @LANGUAGE := 'st' *)
// Axis is valid, but there are errors
ax.statusFpMpAxisBasic.StatusId = mcAXIS_ERR_PLC_OPEN OR
ax.statusFpMpAxisBasic.Error OR
ax.Status.PlcOpenState = mcAXIS_ERRORSTOP OR
ax.Status.PlcOpenState = mcAXIS_INVALID_CONFIGURATION

END_TRANSITION
(* @SFCISJUMP := 'Step_Error_DrvRstWait' *)
END_PROGRAM
